// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: eioserve.proto

/*
	Package eiopb is a generated protocol buffer package.

	It is generated from these files:
		eioserve.proto

	It has these top-level messages:
		Selectors
		Selection
		Year
		Point
		Rectangle
		ColorInfo
*/
package eiopb

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type Selectors struct {
	Codes  []string
	Names  []string
	Values []float32
}

// GetCodes gets the Codes of the Selectors.
func (m *Selectors) GetCodes() (x []string) {
	if m == nil {
		return x
	}
	return m.Codes
}

// GetNames gets the Names of the Selectors.
func (m *Selectors) GetNames() (x []string) {
	if m == nil {
		return x
	}
	return m.Names
}

// GetValues gets the Values of the Selectors.
func (m *Selectors) GetValues() (x []float32) {
	if m == nil {
		return x
	}
	return m.Values
}

// MarshalToWriter marshals Selectors to the provided writer.
func (m *Selectors) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, val := range m.Codes {
		writer.WriteString(1, val)
	}

	for _, val := range m.Names {
		writer.WriteString(2, val)
	}

	if len(m.Values) > 0 {
		writer.WriteFloat32Slice(3, m.Values)
	}

	return
}

// Marshal marshals Selectors to a slice of bytes.
func (m *Selectors) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Selectors from the provided reader.
func (m *Selectors) UnmarshalFromReader(reader jspb.Reader) *Selectors {
	for reader.Next() {
		if m == nil {
			m = &Selectors{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Codes = append(m.Codes, reader.ReadString())
		case 2:
			m.Names = append(m.Names, reader.ReadString())
		case 3:
			m.Values = reader.ReadFloat32Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Selectors from a slice of bytes.
func (m *Selectors) Unmarshal(rawBytes []byte) (*Selectors, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Selection struct {
	DemandGroup      string
	DemandSector     string
	ProductionGroup  string
	ProductionSector string
	ImpactType       string
	DemandType       string
	Year             int32
	Population       string
	Pollutant        int32
}

// GetDemandGroup gets the DemandGroup of the Selection.
func (m *Selection) GetDemandGroup() (x string) {
	if m == nil {
		return x
	}
	return m.DemandGroup
}

// GetDemandSector gets the DemandSector of the Selection.
func (m *Selection) GetDemandSector() (x string) {
	if m == nil {
		return x
	}
	return m.DemandSector
}

// GetProductionGroup gets the ProductionGroup of the Selection.
func (m *Selection) GetProductionGroup() (x string) {
	if m == nil {
		return x
	}
	return m.ProductionGroup
}

// GetProductionSector gets the ProductionSector of the Selection.
func (m *Selection) GetProductionSector() (x string) {
	if m == nil {
		return x
	}
	return m.ProductionSector
}

// GetImpactType gets the ImpactType of the Selection.
func (m *Selection) GetImpactType() (x string) {
	if m == nil {
		return x
	}
	return m.ImpactType
}

// GetDemandType gets the DemandType of the Selection.
func (m *Selection) GetDemandType() (x string) {
	if m == nil {
		return x
	}
	return m.DemandType
}

// GetYear gets the Year of the Selection.
func (m *Selection) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPopulation gets the Population of the Selection.
func (m *Selection) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetPollutant gets the Pollutant of the Selection.
func (m *Selection) GetPollutant() (x int32) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// MarshalToWriter marshals Selection to the provided writer.
func (m *Selection) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.DemandGroup) > 0 {
		writer.WriteString(1, m.DemandGroup)
	}

	if len(m.DemandSector) > 0 {
		writer.WriteString(2, m.DemandSector)
	}

	if len(m.ProductionGroup) > 0 {
		writer.WriteString(3, m.ProductionGroup)
	}

	if len(m.ProductionSector) > 0 {
		writer.WriteString(4, m.ProductionSector)
	}

	if len(m.ImpactType) > 0 {
		writer.WriteString(5, m.ImpactType)
	}

	if len(m.DemandType) > 0 {
		writer.WriteString(6, m.DemandType)
	}

	if m.Year != 0 {
		writer.WriteInt32(7, m.Year)
	}

	if len(m.Population) > 0 {
		writer.WriteString(8, m.Population)
	}

	if m.Pollutant != 0 {
		writer.WriteInt32(9, m.Pollutant)
	}

	return
}

// Marshal marshals Selection to a slice of bytes.
func (m *Selection) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Selection from the provided reader.
func (m *Selection) UnmarshalFromReader(reader jspb.Reader) *Selection {
	for reader.Next() {
		if m == nil {
			m = &Selection{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.DemandGroup = reader.ReadString()
		case 2:
			m.DemandSector = reader.ReadString()
		case 3:
			m.ProductionGroup = reader.ReadString()
		case 4:
			m.ProductionSector = reader.ReadString()
		case 5:
			m.ImpactType = reader.ReadString()
		case 6:
			m.DemandType = reader.ReadString()
		case 7:
			m.Year = reader.ReadInt32()
		case 8:
			m.Population = reader.ReadString()
		case 9:
			m.Pollutant = reader.ReadInt32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Selection from a slice of bytes.
func (m *Selection) Unmarshal(rawBytes []byte) (*Selection, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Year struct {
	Years []int32
}

// GetYears gets the Years of the Year.
func (m *Year) GetYears() (x []int32) {
	if m == nil {
		return x
	}
	return m.Years
}

// MarshalToWriter marshals Year to the provided writer.
func (m *Year) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Years) > 0 {
		writer.WriteInt32Slice(1, m.Years)
	}

	return
}

// Marshal marshals Year to a slice of bytes.
func (m *Year) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Year from the provided reader.
func (m *Year) UnmarshalFromReader(reader jspb.Reader) *Year {
	for reader.Next() {
		if m == nil {
			m = &Year{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Years = reader.ReadInt32Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Year from a slice of bytes.
func (m *Year) Unmarshal(rawBytes []byte) (*Year, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Point struct {
	X float32
	Y float32
}

// GetX gets the X of the Point.
func (m *Point) GetX() (x float32) {
	if m == nil {
		return x
	}
	return m.X
}

// GetY gets the Y of the Point.
func (m *Point) GetY() (x float32) {
	if m == nil {
		return x
	}
	return m.Y
}

// MarshalToWriter marshals Point to the provided writer.
func (m *Point) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.X != 0 {
		writer.WriteFloat32(1, m.X)
	}

	if m.Y != 0 {
		writer.WriteFloat32(2, m.Y)
	}

	return
}

// Marshal marshals Point to a slice of bytes.
func (m *Point) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Point from the provided reader.
func (m *Point) UnmarshalFromReader(reader jspb.Reader) *Point {
	for reader.Next() {
		if m == nil {
			m = &Point{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.X = reader.ReadFloat32()
		case 2:
			m.Y = reader.ReadFloat32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Point from a slice of bytes.
func (m *Point) Unmarshal(rawBytes []byte) (*Point, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Rectangle struct {
	LL *Point
	LR *Point
	UR *Point
	UL *Point
}

// GetLL gets the LL of the Rectangle.
func (m *Rectangle) GetLL() (x *Point) {
	if m == nil {
		return x
	}
	return m.LL
}

// GetLR gets the LR of the Rectangle.
func (m *Rectangle) GetLR() (x *Point) {
	if m == nil {
		return x
	}
	return m.LR
}

// GetUR gets the UR of the Rectangle.
func (m *Rectangle) GetUR() (x *Point) {
	if m == nil {
		return x
	}
	return m.UR
}

// GetUL gets the UL of the Rectangle.
func (m *Rectangle) GetUL() (x *Point) {
	if m == nil {
		return x
	}
	return m.UL
}

// MarshalToWriter marshals Rectangle to the provided writer.
func (m *Rectangle) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.LL != nil {
		writer.WriteMessage(1, func() {
			m.LL.MarshalToWriter(writer)
		})
	}

	if m.LR != nil {
		writer.WriteMessage(2, func() {
			m.LR.MarshalToWriter(writer)
		})
	}

	if m.UR != nil {
		writer.WriteMessage(3, func() {
			m.UR.MarshalToWriter(writer)
		})
	}

	if m.UL != nil {
		writer.WriteMessage(4, func() {
			m.UL.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Rectangle to a slice of bytes.
func (m *Rectangle) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Rectangle from the provided reader.
func (m *Rectangle) UnmarshalFromReader(reader jspb.Reader) *Rectangle {
	for reader.Next() {
		if m == nil {
			m = &Rectangle{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.LL = m.LL.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.LR = m.LR.UnmarshalFromReader(reader)
			})
		case 3:
			reader.ReadMessage(func() {
				m.UR = m.UR.UnmarshalFromReader(reader)
			})
		case 4:
			reader.ReadMessage(func() {
				m.UL = m.UL.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Rectangle from a slice of bytes.
func (m *Rectangle) Unmarshal(rawBytes []byte) (*Rectangle, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ColorInfo struct {
	RGB    [][]byte
	Legend string
}

// GetRGB gets the RGB of the ColorInfo.
func (m *ColorInfo) GetRGB() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.RGB
}

// GetLegend gets the Legend of the ColorInfo.
func (m *ColorInfo) GetLegend() (x string) {
	if m == nil {
		return x
	}
	return m.Legend
}

// MarshalToWriter marshals ColorInfo to the provided writer.
func (m *ColorInfo) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, val := range m.RGB {
		writer.WriteBytes(1, val)
	}

	if len(m.Legend) > 0 {
		writer.WriteString(2, m.Legend)
	}

	return
}

// Marshal marshals ColorInfo to a slice of bytes.
func (m *ColorInfo) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ColorInfo from the provided reader.
func (m *ColorInfo) UnmarshalFromReader(reader jspb.Reader) *ColorInfo {
	for reader.Next() {
		if m == nil {
			m = &ColorInfo{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.RGB = append(m.RGB, reader.ReadBytes())
		case 2:
			m.Legend = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ColorInfo from a slice of bytes.
func (m *ColorInfo) Unmarshal(rawBytes []byte) (*ColorInfo, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for EIOServe service

type EIOServeClient interface {
	DemandGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	DemandSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	ProdGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	ProdSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	Years(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Year, error)
	DefaultSelection(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selection, error)
	Populations(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	MapInfo(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*ColorInfo, error)
	Geometry(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (EIOServe_GeometryClient, error)
}

type eIOServeClient struct {
	client *grpcweb.Client
}

// NewEIOServeClient creates a new gRPC-Web client.
func NewEIOServeClient(hostname string, opts ...grpcweb.DialOption) EIOServeClient {
	return &eIOServeClient{
		client: grpcweb.NewClient(hostname, "eiopb.EIOServe", opts...),
	}
}

func (c *eIOServeClient) DemandGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "DemandGroups", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIOServeClient) DemandSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "DemandSectors", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIOServeClient) ProdGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "ProdGroups", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIOServeClient) ProdSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "ProdSectors", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIOServeClient) Years(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Year, error) {
	resp, err := c.client.RPCCall(ctx, "Years", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Year).Unmarshal(resp)
}

func (c *eIOServeClient) DefaultSelection(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selection, error) {
	resp, err := c.client.RPCCall(ctx, "DefaultSelection", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selection).Unmarshal(resp)
}

func (c *eIOServeClient) Populations(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "Populations", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIOServeClient) MapInfo(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*ColorInfo, error) {
	resp, err := c.client.RPCCall(ctx, "MapInfo", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ColorInfo).Unmarshal(resp)
}

func (c *eIOServeClient) Geometry(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (EIOServe_GeometryClient, error) {
	srv, err := c.client.NewClientStream(ctx, false, true, "Geometry", opts...)
	if err != nil {
		return nil, err
	}

	err = srv.SendMsg(in.Marshal())
	if err != nil {
		return nil, err
	}

	return &eIOServeGeometryClient{srv}, nil
}

type EIOServe_GeometryClient interface {
	Recv() (*Rectangle, error)
	grpcweb.ClientStream
}

type eIOServeGeometryClient struct {
	grpcweb.ClientStream
}

func (x *eIOServeGeometryClient) Recv() (*Rectangle, error) {
	resp, err := x.RecvMsg()
	if err != nil {
		return nil, err
	}

	return new(Rectangle).Unmarshal(resp)
}
