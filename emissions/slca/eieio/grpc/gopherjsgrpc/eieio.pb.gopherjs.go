// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: eieio.proto

/*
	Package eieiorpc is a generated protocol buffer package.

	It is generated from these files:
		eieio.proto

	It has these top-level messages:
		Selectors
		Selection
		Year
		Point
		Rectangle
		ColorInfo
		ConcentrationMatrixInput
		ConcentrationInput
		EmissionsMatrixInput
		EmissionsInput
		HealthMatrixInput
		HealthInput
		Vector
		Matrix
		EvaluationHealthInput
		EvaluationConcentrationsInput
		ConcentrationResponseAverageInput
		PopulationIncidenceInput
		PopulationIncidenceOutput
*/
package eieiorpc

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type Pollutant int

const (
	Pollutant_PNH4        Pollutant = 0
	Pollutant_PNO3        Pollutant = 1
	Pollutant_PSO4        Pollutant = 2
	Pollutant_SOA         Pollutant = 3
	Pollutant_PrimaryPM25 Pollutant = 4
	Pollutant_TotalPM25   Pollutant = 5
)

var Pollutant_name = map[int]string{
	0: "PNH4",
	1: "PNO3",
	2: "PSO4",
	3: "SOA",
	4: "PrimaryPM25",
	5: "TotalPM25",
}
var Pollutant_value = map[string]int{
	"PNH4":        0,
	"PNO3":        1,
	"PSO4":        2,
	"SOA":         3,
	"PrimaryPM25": 4,
	"TotalPM25":   5,
}

func (x Pollutant) String() string {
	return Pollutant_name[int(x)]
}

type Emission int

const (
	Emission_PM25 Emission = 0
	Emission_NH3  Emission = 1
	Emission_NOx  Emission = 2
	Emission_SOx  Emission = 3
	Emission_VOC  Emission = 4
)

var Emission_name = map[int]string{
	0: "PM25",
	1: "NH3",
	2: "NOx",
	3: "SOx",
	4: "VOC",
}
var Emission_value = map[string]int{
	"PM25": 0,
	"NH3":  1,
	"NOx":  2,
	"SOx":  3,
	"VOC":  4,
}

func (x Emission) String() string {
	return Emission_name[int(x)]
}

type Location int

const (
	Location_Domestic Location = 0
	Location_Imported Location = 1
	Location_Total    Location = 2
)

var Location_name = map[int]string{
	0: "Domestic",
	1: "Imported",
	2: "Total",
}
var Location_value = map[string]int{
	"Domestic": 0,
	"Imported": 1,
	"Total":    2,
}

func (x Location) String() string {
	return Location_name[int(x)]
}

type Selectors struct {
	Codes  []string
	Names  []string
	Values []float32
}

// GetCodes gets the Codes of the Selectors.
func (m *Selectors) GetCodes() (x []string) {
	if m == nil {
		return x
	}
	return m.Codes
}

// GetNames gets the Names of the Selectors.
func (m *Selectors) GetNames() (x []string) {
	if m == nil {
		return x
	}
	return m.Names
}

// GetValues gets the Values of the Selectors.
func (m *Selectors) GetValues() (x []float32) {
	if m == nil {
		return x
	}
	return m.Values
}

// MarshalToWriter marshals Selectors to the provided writer.
func (m *Selectors) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, val := range m.Codes {
		writer.WriteString(1, val)
	}

	for _, val := range m.Names {
		writer.WriteString(2, val)
	}

	if len(m.Values) > 0 {
		writer.WriteFloat32Slice(3, m.Values)
	}

	return
}

// Marshal marshals Selectors to a slice of bytes.
func (m *Selectors) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Selectors from the provided reader.
func (m *Selectors) UnmarshalFromReader(reader jspb.Reader) *Selectors {
	for reader.Next() {
		if m == nil {
			m = &Selectors{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Codes = append(m.Codes, reader.ReadString())
		case 2:
			m.Names = append(m.Names, reader.ReadString())
		case 3:
			m.Values = reader.ReadFloat32Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Selectors from a slice of bytes.
func (m *Selectors) Unmarshal(rawBytes []byte) (*Selectors, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Selection struct {
	DemandGroup      string
	DemandSector     string
	ProductionGroup  string
	ProductionSector string
	ImpactType       string
	DemandType       string
	Year             int32
	Population       string
	// Types that are valid to be assigned to Pol:
	//	*Selection_Pollutant
	//	*Selection_Emission
	Pol isSelection_Pol
}

// isSelection_Pol is used to distinguish types assignable to Pol
type isSelection_Pol interface{ isSelection_Pol() }

// Selection_Pollutant is assignable to Pol
type Selection_Pollutant struct {
	Pollutant Pollutant
}

// Selection_Emission is assignable to Pol
type Selection_Emission struct {
	Emission Emission
}

func (*Selection_Pollutant) isSelection_Pol() {}
func (*Selection_Emission) isSelection_Pol()  {}

// GetPol gets the Pol of the Selection.
func (m *Selection) GetPol() (x isSelection_Pol) {
	if m == nil {
		return x
	}
	return m.Pol
}

// GetDemandGroup gets the DemandGroup of the Selection.
func (m *Selection) GetDemandGroup() (x string) {
	if m == nil {
		return x
	}
	return m.DemandGroup
}

// GetDemandSector gets the DemandSector of the Selection.
func (m *Selection) GetDemandSector() (x string) {
	if m == nil {
		return x
	}
	return m.DemandSector
}

// GetProductionGroup gets the ProductionGroup of the Selection.
func (m *Selection) GetProductionGroup() (x string) {
	if m == nil {
		return x
	}
	return m.ProductionGroup
}

// GetProductionSector gets the ProductionSector of the Selection.
func (m *Selection) GetProductionSector() (x string) {
	if m == nil {
		return x
	}
	return m.ProductionSector
}

// GetImpactType gets the ImpactType of the Selection.
func (m *Selection) GetImpactType() (x string) {
	if m == nil {
		return x
	}
	return m.ImpactType
}

// GetDemandType gets the DemandType of the Selection.
func (m *Selection) GetDemandType() (x string) {
	if m == nil {
		return x
	}
	return m.DemandType
}

// GetYear gets the Year of the Selection.
func (m *Selection) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPopulation gets the Population of the Selection.
func (m *Selection) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetPollutant gets the Pollutant of the Selection.
func (m *Selection) GetPollutant() (x Pollutant) {
	if v, ok := m.GetPol().(*Selection_Pollutant); ok {
		return v.Pollutant
	}
	return x
}

// GetEmission gets the Emission of the Selection.
func (m *Selection) GetEmission() (x Emission) {
	if v, ok := m.GetPol().(*Selection_Emission); ok {
		return v.Emission
	}
	return x
}

// MarshalToWriter marshals Selection to the provided writer.
func (m *Selection) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.Pol.(type) {
	case *Selection_Pollutant:
		if int(t.Pollutant) != 0 {
			writer.WriteEnum(9, int(t.Pollutant))
		}
	case *Selection_Emission:
		if int(t.Emission) != 0 {
			writer.WriteEnum(10, int(t.Emission))
		}
	}

	if len(m.DemandGroup) > 0 {
		writer.WriteString(1, m.DemandGroup)
	}

	if len(m.DemandSector) > 0 {
		writer.WriteString(2, m.DemandSector)
	}

	if len(m.ProductionGroup) > 0 {
		writer.WriteString(3, m.ProductionGroup)
	}

	if len(m.ProductionSector) > 0 {
		writer.WriteString(4, m.ProductionSector)
	}

	if len(m.ImpactType) > 0 {
		writer.WriteString(5, m.ImpactType)
	}

	if len(m.DemandType) > 0 {
		writer.WriteString(6, m.DemandType)
	}

	if m.Year != 0 {
		writer.WriteInt32(7, m.Year)
	}

	if len(m.Population) > 0 {
		writer.WriteString(8, m.Population)
	}

	return
}

// Marshal marshals Selection to a slice of bytes.
func (m *Selection) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Selection from the provided reader.
func (m *Selection) UnmarshalFromReader(reader jspb.Reader) *Selection {
	for reader.Next() {
		if m == nil {
			m = &Selection{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.DemandGroup = reader.ReadString()
		case 2:
			m.DemandSector = reader.ReadString()
		case 3:
			m.ProductionGroup = reader.ReadString()
		case 4:
			m.ProductionSector = reader.ReadString()
		case 5:
			m.ImpactType = reader.ReadString()
		case 6:
			m.DemandType = reader.ReadString()
		case 7:
			m.Year = reader.ReadInt32()
		case 8:
			m.Population = reader.ReadString()
		case 9:
			m.Pol = &Selection_Pollutant{
				Pollutant: Pollutant(reader.ReadEnum()),
			}
		case 10:
			m.Pol = &Selection_Emission{
				Emission: Emission(reader.ReadEnum()),
			}
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Selection from a slice of bytes.
func (m *Selection) Unmarshal(rawBytes []byte) (*Selection, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Year struct {
	Years []int32
}

// GetYears gets the Years of the Year.
func (m *Year) GetYears() (x []int32) {
	if m == nil {
		return x
	}
	return m.Years
}

// MarshalToWriter marshals Year to the provided writer.
func (m *Year) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Years) > 0 {
		writer.WriteInt32Slice(1, m.Years)
	}

	return
}

// Marshal marshals Year to a slice of bytes.
func (m *Year) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Year from the provided reader.
func (m *Year) UnmarshalFromReader(reader jspb.Reader) *Year {
	for reader.Next() {
		if m == nil {
			m = &Year{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Years = reader.ReadInt32Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Year from a slice of bytes.
func (m *Year) Unmarshal(rawBytes []byte) (*Year, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Point struct {
	X float32
	Y float32
}

// GetX gets the X of the Point.
func (m *Point) GetX() (x float32) {
	if m == nil {
		return x
	}
	return m.X
}

// GetY gets the Y of the Point.
func (m *Point) GetY() (x float32) {
	if m == nil {
		return x
	}
	return m.Y
}

// MarshalToWriter marshals Point to the provided writer.
func (m *Point) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.X != 0 {
		writer.WriteFloat32(1, m.X)
	}

	if m.Y != 0 {
		writer.WriteFloat32(2, m.Y)
	}

	return
}

// Marshal marshals Point to a slice of bytes.
func (m *Point) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Point from the provided reader.
func (m *Point) UnmarshalFromReader(reader jspb.Reader) *Point {
	for reader.Next() {
		if m == nil {
			m = &Point{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.X = reader.ReadFloat32()
		case 2:
			m.Y = reader.ReadFloat32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Point from a slice of bytes.
func (m *Point) Unmarshal(rawBytes []byte) (*Point, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Rectangle struct {
	LL *Point
	LR *Point
	UR *Point
	UL *Point
}

// GetLL gets the LL of the Rectangle.
func (m *Rectangle) GetLL() (x *Point) {
	if m == nil {
		return x
	}
	return m.LL
}

// GetLR gets the LR of the Rectangle.
func (m *Rectangle) GetLR() (x *Point) {
	if m == nil {
		return x
	}
	return m.LR
}

// GetUR gets the UR of the Rectangle.
func (m *Rectangle) GetUR() (x *Point) {
	if m == nil {
		return x
	}
	return m.UR
}

// GetUL gets the UL of the Rectangle.
func (m *Rectangle) GetUL() (x *Point) {
	if m == nil {
		return x
	}
	return m.UL
}

// MarshalToWriter marshals Rectangle to the provided writer.
func (m *Rectangle) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.LL != nil {
		writer.WriteMessage(1, func() {
			m.LL.MarshalToWriter(writer)
		})
	}

	if m.LR != nil {
		writer.WriteMessage(2, func() {
			m.LR.MarshalToWriter(writer)
		})
	}

	if m.UR != nil {
		writer.WriteMessage(3, func() {
			m.UR.MarshalToWriter(writer)
		})
	}

	if m.UL != nil {
		writer.WriteMessage(4, func() {
			m.UL.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Rectangle to a slice of bytes.
func (m *Rectangle) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Rectangle from the provided reader.
func (m *Rectangle) UnmarshalFromReader(reader jspb.Reader) *Rectangle {
	for reader.Next() {
		if m == nil {
			m = &Rectangle{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.LL = m.LL.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.LR = m.LR.UnmarshalFromReader(reader)
			})
		case 3:
			reader.ReadMessage(func() {
				m.UR = m.UR.UnmarshalFromReader(reader)
			})
		case 4:
			reader.ReadMessage(func() {
				m.UL = m.UL.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Rectangle from a slice of bytes.
func (m *Rectangle) Unmarshal(rawBytes []byte) (*Rectangle, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ColorInfo struct {
	RGB    [][]byte
	Legend string
}

// GetRGB gets the RGB of the ColorInfo.
func (m *ColorInfo) GetRGB() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.RGB
}

// GetLegend gets the Legend of the ColorInfo.
func (m *ColorInfo) GetLegend() (x string) {
	if m == nil {
		return x
	}
	return m.Legend
}

// MarshalToWriter marshals ColorInfo to the provided writer.
func (m *ColorInfo) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, val := range m.RGB {
		writer.WriteBytes(1, val)
	}

	if len(m.Legend) > 0 {
		writer.WriteString(2, m.Legend)
	}

	return
}

// Marshal marshals ColorInfo to a slice of bytes.
func (m *ColorInfo) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ColorInfo from the provided reader.
func (m *ColorInfo) UnmarshalFromReader(reader jspb.Reader) *ColorInfo {
	for reader.Next() {
		if m == nil {
			m = &ColorInfo{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.RGB = append(m.RGB, reader.ReadBytes())
		case 2:
			m.Legend = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ColorInfo from a slice of bytes.
func (m *ColorInfo) Unmarshal(rawBytes []byte) (*ColorInfo, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ConcentrationMatrixInput struct {
	Demand    []float64
	Pollutant Pollutant
	Year      int32
	Location  Location
}

// GetDemand gets the Demand of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetDemand() (x []float64) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetPollutant gets the Pollutant of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetYear gets the Year of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// MarshalToWriter marshals ConcentrationMatrixInput to the provided writer.
func (m *ConcentrationMatrixInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Demand) > 0 {
		writer.WriteFloat64Slice(1, m.Demand)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	if m.Year != 0 {
		writer.WriteInt32(3, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(4, int(m.Location))
	}

	return
}

// Marshal marshals ConcentrationMatrixInput to a slice of bytes.
func (m *ConcentrationMatrixInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ConcentrationMatrixInput from the provided reader.
func (m *ConcentrationMatrixInput) UnmarshalFromReader(reader jspb.Reader) *ConcentrationMatrixInput {
	for reader.Next() {
		if m == nil {
			m = &ConcentrationMatrixInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Demand = reader.ReadFloat64Slice()
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 3:
			m.Year = reader.ReadInt32()
		case 4:
			m.Location = Location(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ConcentrationMatrixInput from a slice of bytes.
func (m *ConcentrationMatrixInput) Unmarshal(rawBytes []byte) (*ConcentrationMatrixInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ConcentrationInput struct {
	Demand     []float64
	Industries []float64
	Pollutant  Pollutant
	Year       int32
	Location   Location
}

// GetDemand gets the Demand of the ConcentrationInput.
func (m *ConcentrationInput) GetDemand() (x []float64) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetIndustries gets the Industries of the ConcentrationInput.
func (m *ConcentrationInput) GetIndustries() (x []float64) {
	if m == nil {
		return x
	}
	return m.Industries
}

// GetPollutant gets the Pollutant of the ConcentrationInput.
func (m *ConcentrationInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetYear gets the Year of the ConcentrationInput.
func (m *ConcentrationInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the ConcentrationInput.
func (m *ConcentrationInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// MarshalToWriter marshals ConcentrationInput to the provided writer.
func (m *ConcentrationInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Demand) > 0 {
		writer.WriteFloat64Slice(1, m.Demand)
	}

	if len(m.Industries) > 0 {
		writer.WriteFloat64Slice(2, m.Industries)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(3, int(m.Pollutant))
	}

	if m.Year != 0 {
		writer.WriteInt32(4, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(5, int(m.Location))
	}

	return
}

// Marshal marshals ConcentrationInput to a slice of bytes.
func (m *ConcentrationInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ConcentrationInput from the provided reader.
func (m *ConcentrationInput) UnmarshalFromReader(reader jspb.Reader) *ConcentrationInput {
	for reader.Next() {
		if m == nil {
			m = &ConcentrationInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Demand = reader.ReadFloat64Slice()
		case 2:
			m.Industries = reader.ReadFloat64Slice()
		case 3:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 4:
			m.Year = reader.ReadInt32()
		case 5:
			m.Location = Location(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ConcentrationInput from a slice of bytes.
func (m *ConcentrationInput) Unmarshal(rawBytes []byte) (*ConcentrationInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EmissionsMatrixInput struct {
	Demand   []float64
	Emission Emission
	Year     int32
	Location Location
}

// GetDemand gets the Demand of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetDemand() (x []float64) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetEmission gets the Emission of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetEmission() (x Emission) {
	if m == nil {
		return x
	}
	return m.Emission
}

// GetYear gets the Year of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// MarshalToWriter marshals EmissionsMatrixInput to the provided writer.
func (m *EmissionsMatrixInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Demand) > 0 {
		writer.WriteFloat64Slice(1, m.Demand)
	}

	if int(m.Emission) != 0 {
		writer.WriteEnum(2, int(m.Emission))
	}

	if m.Year != 0 {
		writer.WriteInt32(3, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(4, int(m.Location))
	}

	return
}

// Marshal marshals EmissionsMatrixInput to a slice of bytes.
func (m *EmissionsMatrixInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EmissionsMatrixInput from the provided reader.
func (m *EmissionsMatrixInput) UnmarshalFromReader(reader jspb.Reader) *EmissionsMatrixInput {
	for reader.Next() {
		if m == nil {
			m = &EmissionsMatrixInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Demand = reader.ReadFloat64Slice()
		case 2:
			m.Emission = Emission(reader.ReadEnum())
		case 3:
			m.Year = reader.ReadInt32()
		case 4:
			m.Location = Location(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EmissionsMatrixInput from a slice of bytes.
func (m *EmissionsMatrixInput) Unmarshal(rawBytes []byte) (*EmissionsMatrixInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EmissionsInput struct {
	Demand     []float64
	Industries []float64
	Emission   Emission
	Year       int32
	Location   Location
}

// GetDemand gets the Demand of the EmissionsInput.
func (m *EmissionsInput) GetDemand() (x []float64) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetIndustries gets the Industries of the EmissionsInput.
func (m *EmissionsInput) GetIndustries() (x []float64) {
	if m == nil {
		return x
	}
	return m.Industries
}

// GetEmission gets the Emission of the EmissionsInput.
func (m *EmissionsInput) GetEmission() (x Emission) {
	if m == nil {
		return x
	}
	return m.Emission
}

// GetYear gets the Year of the EmissionsInput.
func (m *EmissionsInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the EmissionsInput.
func (m *EmissionsInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// MarshalToWriter marshals EmissionsInput to the provided writer.
func (m *EmissionsInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Demand) > 0 {
		writer.WriteFloat64Slice(1, m.Demand)
	}

	if len(m.Industries) > 0 {
		writer.WriteFloat64Slice(2, m.Industries)
	}

	if int(m.Emission) != 0 {
		writer.WriteEnum(3, int(m.Emission))
	}

	if m.Year != 0 {
		writer.WriteInt32(4, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(5, int(m.Location))
	}

	return
}

// Marshal marshals EmissionsInput to a slice of bytes.
func (m *EmissionsInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EmissionsInput from the provided reader.
func (m *EmissionsInput) UnmarshalFromReader(reader jspb.Reader) *EmissionsInput {
	for reader.Next() {
		if m == nil {
			m = &EmissionsInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Demand = reader.ReadFloat64Slice()
		case 2:
			m.Industries = reader.ReadFloat64Slice()
		case 3:
			m.Emission = Emission(reader.ReadEnum())
		case 4:
			m.Year = reader.ReadInt32()
		case 5:
			m.Location = Location(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EmissionsInput from a slice of bytes.
func (m *EmissionsInput) Unmarshal(rawBytes []byte) (*EmissionsInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HealthMatrixInput struct {
	Demand     []float64
	Pollutant  Pollutant
	Population string
	Year       int32
	Location   Location
	HR         string
}

// GetDemand gets the Demand of the HealthMatrixInput.
func (m *HealthMatrixInput) GetDemand() (x []float64) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetPollutant gets the Pollutant of the HealthMatrixInput.
func (m *HealthMatrixInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetPopulation gets the Population of the HealthMatrixInput.
func (m *HealthMatrixInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetYear gets the Year of the HealthMatrixInput.
func (m *HealthMatrixInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the HealthMatrixInput.
func (m *HealthMatrixInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetHR gets the HR of the HealthMatrixInput.
func (m *HealthMatrixInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// MarshalToWriter marshals HealthMatrixInput to the provided writer.
func (m *HealthMatrixInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Demand) > 0 {
		writer.WriteFloat64Slice(1, m.Demand)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	if len(m.Population) > 0 {
		writer.WriteString(3, m.Population)
	}

	if m.Year != 0 {
		writer.WriteInt32(4, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(5, int(m.Location))
	}

	if len(m.HR) > 0 {
		writer.WriteString(6, m.HR)
	}

	return
}

// Marshal marshals HealthMatrixInput to a slice of bytes.
func (m *HealthMatrixInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HealthMatrixInput from the provided reader.
func (m *HealthMatrixInput) UnmarshalFromReader(reader jspb.Reader) *HealthMatrixInput {
	for reader.Next() {
		if m == nil {
			m = &HealthMatrixInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Demand = reader.ReadFloat64Slice()
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 3:
			m.Population = reader.ReadString()
		case 4:
			m.Year = reader.ReadInt32()
		case 5:
			m.Location = Location(reader.ReadEnum())
		case 6:
			m.HR = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HealthMatrixInput from a slice of bytes.
func (m *HealthMatrixInput) Unmarshal(rawBytes []byte) (*HealthMatrixInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HealthInput struct {
	Demand     []float64
	Industries []float64
	Pollutant  Pollutant
	Population string
	Year       int32
	Location   Location
	HR         string
}

// GetDemand gets the Demand of the HealthInput.
func (m *HealthInput) GetDemand() (x []float64) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetIndustries gets the Industries of the HealthInput.
func (m *HealthInput) GetIndustries() (x []float64) {
	if m == nil {
		return x
	}
	return m.Industries
}

// GetPollutant gets the Pollutant of the HealthInput.
func (m *HealthInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetPopulation gets the Population of the HealthInput.
func (m *HealthInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetYear gets the Year of the HealthInput.
func (m *HealthInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the HealthInput.
func (m *HealthInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetHR gets the HR of the HealthInput.
func (m *HealthInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// MarshalToWriter marshals HealthInput to the provided writer.
func (m *HealthInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Demand) > 0 {
		writer.WriteFloat64Slice(1, m.Demand)
	}

	if len(m.Industries) > 0 {
		writer.WriteFloat64Slice(2, m.Industries)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(3, int(m.Pollutant))
	}

	if len(m.Population) > 0 {
		writer.WriteString(4, m.Population)
	}

	if m.Year != 0 {
		writer.WriteInt32(5, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(6, int(m.Location))
	}

	if len(m.HR) > 0 {
		writer.WriteString(7, m.HR)
	}

	return
}

// Marshal marshals HealthInput to a slice of bytes.
func (m *HealthInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HealthInput from the provided reader.
func (m *HealthInput) UnmarshalFromReader(reader jspb.Reader) *HealthInput {
	for reader.Next() {
		if m == nil {
			m = &HealthInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Demand = reader.ReadFloat64Slice()
		case 2:
			m.Industries = reader.ReadFloat64Slice()
		case 3:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 4:
			m.Population = reader.ReadString()
		case 5:
			m.Year = reader.ReadInt32()
		case 6:
			m.Location = Location(reader.ReadEnum())
		case 7:
			m.HR = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HealthInput from a slice of bytes.
func (m *HealthInput) Unmarshal(rawBytes []byte) (*HealthInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Vector struct {
	Data []float64
}

// GetData gets the Data of the Vector.
func (m *Vector) GetData() (x []float64) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals Vector to the provided writer.
func (m *Vector) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Data) > 0 {
		writer.WriteFloat64Slice(1, m.Data)
	}

	return
}

// Marshal marshals Vector to a slice of bytes.
func (m *Vector) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Vector from the provided reader.
func (m *Vector) UnmarshalFromReader(reader jspb.Reader) *Vector {
	for reader.Next() {
		if m == nil {
			m = &Vector{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Data = reader.ReadFloat64Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Vector from a slice of bytes.
func (m *Vector) Unmarshal(rawBytes []byte) (*Vector, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Matrix struct {
	Rows int32
	Cols int32
	Data []float64
}

// GetRows gets the Rows of the Matrix.
func (m *Matrix) GetRows() (x int32) {
	if m == nil {
		return x
	}
	return m.Rows
}

// GetCols gets the Cols of the Matrix.
func (m *Matrix) GetCols() (x int32) {
	if m == nil {
		return x
	}
	return m.Cols
}

// GetData gets the Data of the Matrix.
func (m *Matrix) GetData() (x []float64) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals Matrix to the provided writer.
func (m *Matrix) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Rows != 0 {
		writer.WriteInt32(1, m.Rows)
	}

	if m.Cols != 0 {
		writer.WriteInt32(2, m.Cols)
	}

	if len(m.Data) > 0 {
		writer.WriteFloat64Slice(3, m.Data)
	}

	return
}

// Marshal marshals Matrix to a slice of bytes.
func (m *Matrix) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Matrix from the provided reader.
func (m *Matrix) UnmarshalFromReader(reader jspb.Reader) *Matrix {
	for reader.Next() {
		if m == nil {
			m = &Matrix{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Rows = reader.ReadInt32()
		case 2:
			m.Cols = reader.ReadInt32()
		case 3:
			m.Data = reader.ReadFloat64Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Matrix from a slice of bytes.
func (m *Matrix) Unmarshal(rawBytes []byte) (*Matrix, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EvaluationHealthInput struct {
	Year       int32
	Pollutant  Pollutant
	Population string
	HR         string
}

// GetYear gets the Year of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPollutant gets the Pollutant of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetPopulation gets the Population of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetHR gets the HR of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// MarshalToWriter marshals EvaluationHealthInput to the provided writer.
func (m *EvaluationHealthInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	if len(m.Population) > 0 {
		writer.WriteString(3, m.Population)
	}

	if len(m.HR) > 0 {
		writer.WriteString(4, m.HR)
	}

	return
}

// Marshal marshals EvaluationHealthInput to a slice of bytes.
func (m *EvaluationHealthInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EvaluationHealthInput from the provided reader.
func (m *EvaluationHealthInput) UnmarshalFromReader(reader jspb.Reader) *EvaluationHealthInput {
	for reader.Next() {
		if m == nil {
			m = &EvaluationHealthInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 3:
			m.Population = reader.ReadString()
		case 4:
			m.HR = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EvaluationHealthInput from a slice of bytes.
func (m *EvaluationHealthInput) Unmarshal(rawBytes []byte) (*EvaluationHealthInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EvaluationConcentrationsInput struct {
	Year      int32
	Pollutant Pollutant
}

// GetYear gets the Year of the EvaluationConcentrationsInput.
func (m *EvaluationConcentrationsInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPollutant gets the Pollutant of the EvaluationConcentrationsInput.
func (m *EvaluationConcentrationsInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// MarshalToWriter marshals EvaluationConcentrationsInput to the provided writer.
func (m *EvaluationConcentrationsInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	return
}

// Marshal marshals EvaluationConcentrationsInput to a slice of bytes.
func (m *EvaluationConcentrationsInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EvaluationConcentrationsInput from the provided reader.
func (m *EvaluationConcentrationsInput) UnmarshalFromReader(reader jspb.Reader) *EvaluationConcentrationsInput {
	for reader.Next() {
		if m == nil {
			m = &EvaluationConcentrationsInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EvaluationConcentrationsInput from a slice of bytes.
func (m *EvaluationConcentrationsInput) Unmarshal(rawBytes []byte) (*EvaluationConcentrationsInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ConcentrationResponseAverageInput struct {
	Year       int32
	Population string
	HR         string
}

// GetYear gets the Year of the ConcentrationResponseAverageInput.
func (m *ConcentrationResponseAverageInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPopulation gets the Population of the ConcentrationResponseAverageInput.
func (m *ConcentrationResponseAverageInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetHR gets the HR of the ConcentrationResponseAverageInput.
func (m *ConcentrationResponseAverageInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// MarshalToWriter marshals ConcentrationResponseAverageInput to the provided writer.
func (m *ConcentrationResponseAverageInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if len(m.Population) > 0 {
		writer.WriteString(2, m.Population)
	}

	if len(m.HR) > 0 {
		writer.WriteString(3, m.HR)
	}

	return
}

// Marshal marshals ConcentrationResponseAverageInput to a slice of bytes.
func (m *ConcentrationResponseAverageInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ConcentrationResponseAverageInput from the provided reader.
func (m *ConcentrationResponseAverageInput) UnmarshalFromReader(reader jspb.Reader) *ConcentrationResponseAverageInput {
	for reader.Next() {
		if m == nil {
			m = &ConcentrationResponseAverageInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Population = reader.ReadString()
		case 3:
			m.HR = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ConcentrationResponseAverageInput from a slice of bytes.
func (m *ConcentrationResponseAverageInput) Unmarshal(rawBytes []byte) (*ConcentrationResponseAverageInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type PopulationIncidenceInput struct {
	Year       int32
	Population string
	HR         string
}

// GetYear gets the Year of the PopulationIncidenceInput.
func (m *PopulationIncidenceInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPopulation gets the Population of the PopulationIncidenceInput.
func (m *PopulationIncidenceInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetHR gets the HR of the PopulationIncidenceInput.
func (m *PopulationIncidenceInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// MarshalToWriter marshals PopulationIncidenceInput to the provided writer.
func (m *PopulationIncidenceInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if len(m.Population) > 0 {
		writer.WriteString(2, m.Population)
	}

	if len(m.HR) > 0 {
		writer.WriteString(3, m.HR)
	}

	return
}

// Marshal marshals PopulationIncidenceInput to a slice of bytes.
func (m *PopulationIncidenceInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a PopulationIncidenceInput from the provided reader.
func (m *PopulationIncidenceInput) UnmarshalFromReader(reader jspb.Reader) *PopulationIncidenceInput {
	for reader.Next() {
		if m == nil {
			m = &PopulationIncidenceInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Population = reader.ReadString()
		case 3:
			m.HR = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a PopulationIncidenceInput from a slice of bytes.
func (m *PopulationIncidenceInput) Unmarshal(rawBytes []byte) (*PopulationIncidenceInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type PopulationIncidenceOutput struct {
	Population []float64
	Incidence  []float64
}

// GetPopulation gets the Population of the PopulationIncidenceOutput.
func (m *PopulationIncidenceOutput) GetPopulation() (x []float64) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetIncidence gets the Incidence of the PopulationIncidenceOutput.
func (m *PopulationIncidenceOutput) GetIncidence() (x []float64) {
	if m == nil {
		return x
	}
	return m.Incidence
}

// MarshalToWriter marshals PopulationIncidenceOutput to the provided writer.
func (m *PopulationIncidenceOutput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Population) > 0 {
		writer.WriteFloat64Slice(1, m.Population)
	}

	if len(m.Incidence) > 0 {
		writer.WriteFloat64Slice(2, m.Incidence)
	}

	return
}

// Marshal marshals PopulationIncidenceOutput to a slice of bytes.
func (m *PopulationIncidenceOutput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a PopulationIncidenceOutput from the provided reader.
func (m *PopulationIncidenceOutput) UnmarshalFromReader(reader jspb.Reader) *PopulationIncidenceOutput {
	for reader.Next() {
		if m == nil {
			m = &PopulationIncidenceOutput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Population = reader.ReadFloat64Slice()
		case 2:
			m.Incidence = reader.ReadFloat64Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a PopulationIncidenceOutput from a slice of bytes.
func (m *PopulationIncidenceOutput) Unmarshal(rawBytes []byte) (*PopulationIncidenceOutput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for EIEIOrpc service

type EIEIOrpcClient interface {
	DemandGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	DemandSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	ProdGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	ProdSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	Years(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Year, error)
	DefaultSelection(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selection, error)
	Populations(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	MapInfo(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*ColorInfo, error)
	Geometry(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (EIEIOrpc_GeometryClient, error)
	Concentrations(ctx context.Context, in *ConcentrationInput, opts ...grpcweb.CallOption) (*Vector, error)
	ConcentrationMatrix(ctx context.Context, in *ConcentrationMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error)
	Emissions(ctx context.Context, in *EmissionsInput, opts ...grpcweb.CallOption) (*Vector, error)
	EmissionsMatrix(ctx context.Context, in *EmissionsMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error)
	Health(ctx context.Context, in *HealthInput, opts ...grpcweb.CallOption) (*Vector, error)
	HealthMatrix(ctx context.Context, in *HealthMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error)
	EvaluationHealth(ctx context.Context, in *EvaluationHealthInput, opts ...grpcweb.CallOption) (*Vector, error)
	EvaluationConcentrations(ctx context.Context, in *EvaluationConcentrationsInput, opts ...grpcweb.CallOption) (*Vector, error)
	ConcentrationResponseAverage(ctx context.Context, in *ConcentrationResponseAverageInput, opts ...grpcweb.CallOption) (*Vector, error)
	PopulationIncidence(ctx context.Context, in *PopulationIncidenceInput, opts ...grpcweb.CallOption) (*PopulationIncidenceOutput, error)
}

type eIEIOrpcClient struct {
	client *grpcweb.Client
}

// NewEIEIOrpcClient creates a new gRPC-Web client.
func NewEIEIOrpcClient(hostname string, opts ...grpcweb.DialOption) EIEIOrpcClient {
	return &eIEIOrpcClient{
		client: grpcweb.NewClient(hostname, "eieiorpc.EIEIOrpc", opts...),
	}
}

func (c *eIEIOrpcClient) DemandGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "DemandGroups", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) DemandSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "DemandSectors", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) ProdGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "ProdGroups", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) ProdSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "ProdSectors", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Years(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Year, error) {
	resp, err := c.client.RPCCall(ctx, "Years", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Year).Unmarshal(resp)
}

func (c *eIEIOrpcClient) DefaultSelection(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selection, error) {
	resp, err := c.client.RPCCall(ctx, "DefaultSelection", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selection).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Populations(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "Populations", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) MapInfo(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*ColorInfo, error) {
	resp, err := c.client.RPCCall(ctx, "MapInfo", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ColorInfo).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Geometry(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (EIEIOrpc_GeometryClient, error) {
	srv, err := c.client.NewClientStream(ctx, false, true, "Geometry", opts...)
	if err != nil {
		return nil, err
	}

	err = srv.SendMsg(in.Marshal())
	if err != nil {
		return nil, err
	}

	return &eIEIOrpcGeometryClient{srv}, nil
}

type EIEIOrpc_GeometryClient interface {
	Recv() (*Rectangle, error)
	grpcweb.ClientStream
}

type eIEIOrpcGeometryClient struct {
	grpcweb.ClientStream
}

func (x *eIEIOrpcGeometryClient) Recv() (*Rectangle, error) {
	resp, err := x.RecvMsg()
	if err != nil {
		return nil, err
	}

	return new(Rectangle).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Concentrations(ctx context.Context, in *ConcentrationInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "Concentrations", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) ConcentrationMatrix(ctx context.Context, in *ConcentrationMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error) {
	resp, err := c.client.RPCCall(ctx, "ConcentrationMatrix", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Matrix).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Emissions(ctx context.Context, in *EmissionsInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "Emissions", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EmissionsMatrix(ctx context.Context, in *EmissionsMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error) {
	resp, err := c.client.RPCCall(ctx, "EmissionsMatrix", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Matrix).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Health(ctx context.Context, in *HealthInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "Health", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) HealthMatrix(ctx context.Context, in *HealthMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error) {
	resp, err := c.client.RPCCall(ctx, "HealthMatrix", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Matrix).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EvaluationHealth(ctx context.Context, in *EvaluationHealthInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "EvaluationHealth", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EvaluationConcentrations(ctx context.Context, in *EvaluationConcentrationsInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "EvaluationConcentrations", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) ConcentrationResponseAverage(ctx context.Context, in *ConcentrationResponseAverageInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "ConcentrationResponseAverage", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) PopulationIncidence(ctx context.Context, in *PopulationIncidenceInput, opts ...grpcweb.CallOption) (*PopulationIncidenceOutput, error) {
	resp, err := c.client.RPCCall(ctx, "PopulationIncidence", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(PopulationIncidenceOutput).Unmarshal(resp)
}
