// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: eieio.proto

/*
	Package eieiorpc is a generated protocol buffer package.

	It is generated from these files:
		eieio.proto

	It has these top-level messages:
		StringInput
		StringList
		Selectors
		Selection
		Year
		Point
		Rectangle
		Rectangles
		GeometryInput
		ColorInfo
		FinalDemandInput
		DemographicConsumptionInput
		ConcentrationMatrixInput
		ConcentrationInput
		EmissionsMatrixInput
		EmissionsInput
		HealthMatrixInput
		HealthInput
		Vector
		Mask
		Matrix
		EvaluationHealthInput
		EvaluationConcentrationsInput
		ConcentrationResponseAverageInput
		PopulationIncidenceInput
		PopulationIncidenceOutput
*/
package eieiorpc

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type Pollutant int

const (
	Pollutant_PNH4        Pollutant = 0
	Pollutant_PNO3        Pollutant = 1
	Pollutant_PSO4        Pollutant = 2
	Pollutant_SOA         Pollutant = 3
	Pollutant_PrimaryPM25 Pollutant = 4
	Pollutant_TotalPM25   Pollutant = 5
)

var Pollutant_name = map[int]string{
	0: "PNH4",
	1: "PNO3",
	2: "PSO4",
	3: "SOA",
	4: "PrimaryPM25",
	5: "TotalPM25",
}
var Pollutant_value = map[string]int{
	"PNH4":        0,
	"PNO3":        1,
	"PSO4":        2,
	"SOA":         3,
	"PrimaryPM25": 4,
	"TotalPM25":   5,
}

func (x Pollutant) String() string {
	return Pollutant_name[int(x)]
}

type Emission int

const (
	Emission_PM25 Emission = 0
	Emission_NH3  Emission = 1
	Emission_NOx  Emission = 2
	Emission_SOx  Emission = 3
	Emission_VOC  Emission = 4
)

var Emission_name = map[int]string{
	0: "PM25",
	1: "NH3",
	2: "NOx",
	3: "SOx",
	4: "VOC",
}
var Emission_value = map[string]int{
	"PM25": 0,
	"NH3":  1,
	"NOx":  2,
	"SOx":  3,
	"VOC":  4,
}

func (x Emission) String() string {
	return Emission_name[int(x)]
}

type Location int

const (
	Location_Domestic Location = 0
	Location_Imported Location = 1
	Location_Total    Location = 2
)

var Location_name = map[int]string{
	0: "Domestic",
	1: "Imported",
	2: "Total",
}
var Location_value = map[string]int{
	"Domestic": 0,
	"Imported": 1,
	"Total":    2,
}

func (x Location) String() string {
	return Location_name[int(x)]
}

type FinalDemandType int

const (
	// This group of demand types is directly available in the spreadsheet.
	FinalDemandType_PersonalConsumption   FinalDemandType = 0
	FinalDemandType_PrivateStructures     FinalDemandType = 1
	FinalDemandType_PrivateEquipment      FinalDemandType = 2
	FinalDemandType_PrivateIP             FinalDemandType = 3
	FinalDemandType_PrivateResidential    FinalDemandType = 4
	FinalDemandType_InventoryChange       FinalDemandType = 5
	FinalDemandType_Export                FinalDemandType = 6
	FinalDemandType_DefenseConsumption    FinalDemandType = 7
	FinalDemandType_DefenseStructures     FinalDemandType = 8
	FinalDemandType_DefenseEquipment      FinalDemandType = 9
	FinalDemandType_DefenseIP             FinalDemandType = 10
	FinalDemandType_NondefenseConsumption FinalDemandType = 11
	FinalDemandType_NondefenseStructures  FinalDemandType = 12
	FinalDemandType_NondefenseEquipment   FinalDemandType = 13
	FinalDemandType_NondefenseIP          FinalDemandType = 14
	FinalDemandType_LocalConsumption      FinalDemandType = 15
	FinalDemandType_LocalStructures       FinalDemandType = 16
	FinalDemandType_LocalEquipment        FinalDemandType = 17
	FinalDemandType_LocalIP               FinalDemandType = 18
	// This group of demand types consists of aggregates of the
	// above types.
	FinalDemandType_AllDemand FinalDemandType = 19
	FinalDemandType_NonExport FinalDemandType = 20
)

var FinalDemandType_name = map[int]string{
	0:  "PersonalConsumption",
	1:  "PrivateStructures",
	2:  "PrivateEquipment",
	3:  "PrivateIP",
	4:  "PrivateResidential",
	5:  "InventoryChange",
	6:  "Export",
	7:  "DefenseConsumption",
	8:  "DefenseStructures",
	9:  "DefenseEquipment",
	10: "DefenseIP",
	11: "NondefenseConsumption",
	12: "NondefenseStructures",
	13: "NondefenseEquipment",
	14: "NondefenseIP",
	15: "LocalConsumption",
	16: "LocalStructures",
	17: "LocalEquipment",
	18: "LocalIP",
	19: "AllDemand",
	20: "NonExport",
}
var FinalDemandType_value = map[string]int{
	"PersonalConsumption":   0,
	"PrivateStructures":     1,
	"PrivateEquipment":      2,
	"PrivateIP":             3,
	"PrivateResidential":    4,
	"InventoryChange":       5,
	"Export":                6,
	"DefenseConsumption":    7,
	"DefenseStructures":     8,
	"DefenseEquipment":      9,
	"DefenseIP":             10,
	"NondefenseConsumption": 11,
	"NondefenseStructures":  12,
	"NondefenseEquipment":   13,
	"NondefenseIP":          14,
	"LocalConsumption":      15,
	"LocalStructures":       16,
	"LocalEquipment":        17,
	"LocalIP":               18,
	"AllDemand":             19,
	"NonExport":             20,
}

func (x FinalDemandType) String() string {
	return FinalDemandType_name[int(x)]
}

// These are the included demographic groups.
type Demograph int

const (
	Demograph_Black      Demograph = 0
	Demograph_Hispanic   Demograph = 1
	Demograph_WhiteOther Demograph = 2
	Demograph_All        Demograph = 3
)

var Demograph_name = map[int]string{
	0: "Black",
	1: "Hispanic",
	2: "WhiteOther",
	3: "All",
}
var Demograph_value = map[string]int{
	"Black":      0,
	"Hispanic":   1,
	"WhiteOther": 2,
	"All":        3,
}

func (x Demograph) String() string {
	return Demograph_name[int(x)]
}

type StringInput struct {
	String string
}

// GetString gets the String of the StringInput.
func (m *StringInput) GetString() (x string) {
	if m == nil {
		return x
	}
	return m.String
}

// MarshalToWriter marshals StringInput to the provided writer.
func (m *StringInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.String) > 0 {
		writer.WriteString(1, m.String)
	}

	return
}

// Marshal marshals StringInput to a slice of bytes.
func (m *StringInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a StringInput from the provided reader.
func (m *StringInput) UnmarshalFromReader(reader jspb.Reader) *StringInput {
	for reader.Next() {
		if m == nil {
			m = &StringInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.String = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a StringInput from a slice of bytes.
func (m *StringInput) Unmarshal(rawBytes []byte) (*StringInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type StringList struct {
	List []string
}

// GetList gets the List of the StringList.
func (m *StringList) GetList() (x []string) {
	if m == nil {
		return x
	}
	return m.List
}

// MarshalToWriter marshals StringList to the provided writer.
func (m *StringList) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, val := range m.List {
		writer.WriteString(1, val)
	}

	return
}

// Marshal marshals StringList to a slice of bytes.
func (m *StringList) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a StringList from the provided reader.
func (m *StringList) UnmarshalFromReader(reader jspb.Reader) *StringList {
	for reader.Next() {
		if m == nil {
			m = &StringList{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.List = append(m.List, reader.ReadString())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a StringList from a slice of bytes.
func (m *StringList) Unmarshal(rawBytes []byte) (*StringList, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Selectors struct {
	Codes  []string
	Names  []string
	Values []float32
}

// GetCodes gets the Codes of the Selectors.
func (m *Selectors) GetCodes() (x []string) {
	if m == nil {
		return x
	}
	return m.Codes
}

// GetNames gets the Names of the Selectors.
func (m *Selectors) GetNames() (x []string) {
	if m == nil {
		return x
	}
	return m.Names
}

// GetValues gets the Values of the Selectors.
func (m *Selectors) GetValues() (x []float32) {
	if m == nil {
		return x
	}
	return m.Values
}

// MarshalToWriter marshals Selectors to the provided writer.
func (m *Selectors) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, val := range m.Codes {
		writer.WriteString(1, val)
	}

	for _, val := range m.Names {
		writer.WriteString(2, val)
	}

	if len(m.Values) > 0 {
		writer.WriteFloat32Slice(3, m.Values)
	}

	return
}

// Marshal marshals Selectors to a slice of bytes.
func (m *Selectors) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Selectors from the provided reader.
func (m *Selectors) UnmarshalFromReader(reader jspb.Reader) *Selectors {
	for reader.Next() {
		if m == nil {
			m = &Selectors{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Codes = append(m.Codes, reader.ReadString())
		case 2:
			m.Names = append(m.Names, reader.ReadString())
		case 3:
			m.Values = reader.ReadFloat32Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Selectors from a slice of bytes.
func (m *Selectors) Unmarshal(rawBytes []byte) (*Selectors, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Selection struct {
	EndUseGroup     string
	EndUseSector    string
	EmitterGroup    string
	EmitterSector   string
	ImpactType      string
	FinalDemandType FinalDemandType
	Year            int32
	Population      string
	// Types that are valid to be assigned to Pol:
	//	*Selection_Pollutant
	//	*Selection_Emission
	Pol isSelection_Pol
	AQM string
}

// isSelection_Pol is used to distinguish types assignable to Pol
type isSelection_Pol interface{ isSelection_Pol() }

// Selection_Pollutant is assignable to Pol
type Selection_Pollutant struct {
	Pollutant Pollutant
}

// Selection_Emission is assignable to Pol
type Selection_Emission struct {
	Emission Emission
}

func (*Selection_Pollutant) isSelection_Pol() {}
func (*Selection_Emission) isSelection_Pol()  {}

// GetPol gets the Pol of the Selection.
func (m *Selection) GetPol() (x isSelection_Pol) {
	if m == nil {
		return x
	}
	return m.Pol
}

// GetEndUseGroup gets the EndUseGroup of the Selection.
func (m *Selection) GetEndUseGroup() (x string) {
	if m == nil {
		return x
	}
	return m.EndUseGroup
}

// GetEndUseSector gets the EndUseSector of the Selection.
func (m *Selection) GetEndUseSector() (x string) {
	if m == nil {
		return x
	}
	return m.EndUseSector
}

// GetEmitterGroup gets the EmitterGroup of the Selection.
func (m *Selection) GetEmitterGroup() (x string) {
	if m == nil {
		return x
	}
	return m.EmitterGroup
}

// GetEmitterSector gets the EmitterSector of the Selection.
func (m *Selection) GetEmitterSector() (x string) {
	if m == nil {
		return x
	}
	return m.EmitterSector
}

// GetImpactType gets the ImpactType of the Selection.
func (m *Selection) GetImpactType() (x string) {
	if m == nil {
		return x
	}
	return m.ImpactType
}

// GetFinalDemandType gets the FinalDemandType of the Selection.
func (m *Selection) GetFinalDemandType() (x FinalDemandType) {
	if m == nil {
		return x
	}
	return m.FinalDemandType
}

// GetYear gets the Year of the Selection.
func (m *Selection) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPopulation gets the Population of the Selection.
func (m *Selection) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetPollutant gets the Pollutant of the Selection.
func (m *Selection) GetPollutant() (x Pollutant) {
	if v, ok := m.GetPol().(*Selection_Pollutant); ok {
		return v.Pollutant
	}
	return x
}

// GetEmission gets the Emission of the Selection.
func (m *Selection) GetEmission() (x Emission) {
	if v, ok := m.GetPol().(*Selection_Emission); ok {
		return v.Emission
	}
	return x
}

// GetAQM gets the AQM of the Selection.
func (m *Selection) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals Selection to the provided writer.
func (m *Selection) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.Pol.(type) {
	case *Selection_Pollutant:
		if int(t.Pollutant) != 0 {
			writer.WriteEnum(9, int(t.Pollutant))
		}
	case *Selection_Emission:
		if int(t.Emission) != 0 {
			writer.WriteEnum(10, int(t.Emission))
		}
	}

	if len(m.EndUseGroup) > 0 {
		writer.WriteString(1, m.EndUseGroup)
	}

	if len(m.EndUseSector) > 0 {
		writer.WriteString(2, m.EndUseSector)
	}

	if len(m.EmitterGroup) > 0 {
		writer.WriteString(3, m.EmitterGroup)
	}

	if len(m.EmitterSector) > 0 {
		writer.WriteString(4, m.EmitterSector)
	}

	if len(m.ImpactType) > 0 {
		writer.WriteString(5, m.ImpactType)
	}

	if int(m.FinalDemandType) != 0 {
		writer.WriteEnum(6, int(m.FinalDemandType))
	}

	if m.Year != 0 {
		writer.WriteInt32(7, m.Year)
	}

	if len(m.Population) > 0 {
		writer.WriteString(8, m.Population)
	}

	if len(m.AQM) > 0 {
		writer.WriteString(11, m.AQM)
	}

	return
}

// Marshal marshals Selection to a slice of bytes.
func (m *Selection) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Selection from the provided reader.
func (m *Selection) UnmarshalFromReader(reader jspb.Reader) *Selection {
	for reader.Next() {
		if m == nil {
			m = &Selection{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.EndUseGroup = reader.ReadString()
		case 2:
			m.EndUseSector = reader.ReadString()
		case 3:
			m.EmitterGroup = reader.ReadString()
		case 4:
			m.EmitterSector = reader.ReadString()
		case 5:
			m.ImpactType = reader.ReadString()
		case 6:
			m.FinalDemandType = FinalDemandType(reader.ReadEnum())
		case 7:
			m.Year = reader.ReadInt32()
		case 8:
			m.Population = reader.ReadString()
		case 9:
			m.Pol = &Selection_Pollutant{
				Pollutant: Pollutant(reader.ReadEnum()),
			}
		case 10:
			m.Pol = &Selection_Emission{
				Emission: Emission(reader.ReadEnum()),
			}
		case 11:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Selection from a slice of bytes.
func (m *Selection) Unmarshal(rawBytes []byte) (*Selection, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Year struct {
	Years []int32
}

// GetYears gets the Years of the Year.
func (m *Year) GetYears() (x []int32) {
	if m == nil {
		return x
	}
	return m.Years
}

// MarshalToWriter marshals Year to the provided writer.
func (m *Year) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Years) > 0 {
		writer.WriteInt32Slice(1, m.Years)
	}

	return
}

// Marshal marshals Year to a slice of bytes.
func (m *Year) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Year from the provided reader.
func (m *Year) UnmarshalFromReader(reader jspb.Reader) *Year {
	for reader.Next() {
		if m == nil {
			m = &Year{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Years = reader.ReadInt32Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Year from a slice of bytes.
func (m *Year) Unmarshal(rawBytes []byte) (*Year, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Point struct {
	X float32
	Y float32
}

// GetX gets the X of the Point.
func (m *Point) GetX() (x float32) {
	if m == nil {
		return x
	}
	return m.X
}

// GetY gets the Y of the Point.
func (m *Point) GetY() (x float32) {
	if m == nil {
		return x
	}
	return m.Y
}

// MarshalToWriter marshals Point to the provided writer.
func (m *Point) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.X != 0 {
		writer.WriteFloat32(1, m.X)
	}

	if m.Y != 0 {
		writer.WriteFloat32(2, m.Y)
	}

	return
}

// Marshal marshals Point to a slice of bytes.
func (m *Point) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Point from the provided reader.
func (m *Point) UnmarshalFromReader(reader jspb.Reader) *Point {
	for reader.Next() {
		if m == nil {
			m = &Point{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.X = reader.ReadFloat32()
		case 2:
			m.Y = reader.ReadFloat32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Point from a slice of bytes.
func (m *Point) Unmarshal(rawBytes []byte) (*Point, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Rectangle struct {
	LL *Point
	LR *Point
	UR *Point
	UL *Point
}

// GetLL gets the LL of the Rectangle.
func (m *Rectangle) GetLL() (x *Point) {
	if m == nil {
		return x
	}
	return m.LL
}

// GetLR gets the LR of the Rectangle.
func (m *Rectangle) GetLR() (x *Point) {
	if m == nil {
		return x
	}
	return m.LR
}

// GetUR gets the UR of the Rectangle.
func (m *Rectangle) GetUR() (x *Point) {
	if m == nil {
		return x
	}
	return m.UR
}

// GetUL gets the UL of the Rectangle.
func (m *Rectangle) GetUL() (x *Point) {
	if m == nil {
		return x
	}
	return m.UL
}

// MarshalToWriter marshals Rectangle to the provided writer.
func (m *Rectangle) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.LL != nil {
		writer.WriteMessage(1, func() {
			m.LL.MarshalToWriter(writer)
		})
	}

	if m.LR != nil {
		writer.WriteMessage(2, func() {
			m.LR.MarshalToWriter(writer)
		})
	}

	if m.UR != nil {
		writer.WriteMessage(3, func() {
			m.UR.MarshalToWriter(writer)
		})
	}

	if m.UL != nil {
		writer.WriteMessage(4, func() {
			m.UL.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Rectangle to a slice of bytes.
func (m *Rectangle) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Rectangle from the provided reader.
func (m *Rectangle) UnmarshalFromReader(reader jspb.Reader) *Rectangle {
	for reader.Next() {
		if m == nil {
			m = &Rectangle{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.LL = m.LL.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.LR = m.LR.UnmarshalFromReader(reader)
			})
		case 3:
			reader.ReadMessage(func() {
				m.UR = m.UR.UnmarshalFromReader(reader)
			})
		case 4:
			reader.ReadMessage(func() {
				m.UL = m.UL.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Rectangle from a slice of bytes.
func (m *Rectangle) Unmarshal(rawBytes []byte) (*Rectangle, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Rectangles struct {
	Rectangles []*Rectangle
}

// GetRectangles gets the Rectangles of the Rectangles.
func (m *Rectangles) GetRectangles() (x []*Rectangle) {
	if m == nil {
		return x
	}
	return m.Rectangles
}

// MarshalToWriter marshals Rectangles to the provided writer.
func (m *Rectangles) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, msg := range m.Rectangles {
		writer.WriteMessage(1, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Rectangles to a slice of bytes.
func (m *Rectangles) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Rectangles from the provided reader.
func (m *Rectangles) UnmarshalFromReader(reader jspb.Reader) *Rectangles {
	for reader.Next() {
		if m == nil {
			m = &Rectangles{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Rectangles = append(m.Rectangles, new(Rectangle).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Rectangles from a slice of bytes.
func (m *Rectangles) Unmarshal(rawBytes []byte) (*Rectangles, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GeometryInput struct {
	SpatialReference string
	AQM              string
}

// GetSpatialReference gets the SpatialReference of the GeometryInput.
func (m *GeometryInput) GetSpatialReference() (x string) {
	if m == nil {
		return x
	}
	return m.SpatialReference
}

// GetAQM gets the AQM of the GeometryInput.
func (m *GeometryInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals GeometryInput to the provided writer.
func (m *GeometryInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.SpatialReference) > 0 {
		writer.WriteString(1, m.SpatialReference)
	}

	if len(m.AQM) > 0 {
		writer.WriteString(2, m.AQM)
	}

	return
}

// Marshal marshals GeometryInput to a slice of bytes.
func (m *GeometryInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GeometryInput from the provided reader.
func (m *GeometryInput) UnmarshalFromReader(reader jspb.Reader) *GeometryInput {
	for reader.Next() {
		if m == nil {
			m = &GeometryInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.SpatialReference = reader.ReadString()
		case 2:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GeometryInput from a slice of bytes.
func (m *GeometryInput) Unmarshal(rawBytes []byte) (*GeometryInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ColorInfo struct {
	RGB    [][]byte
	Legend string
}

// GetRGB gets the RGB of the ColorInfo.
func (m *ColorInfo) GetRGB() (x [][]byte) {
	if m == nil {
		return x
	}
	return m.RGB
}

// GetLegend gets the Legend of the ColorInfo.
func (m *ColorInfo) GetLegend() (x string) {
	if m == nil {
		return x
	}
	return m.Legend
}

// MarshalToWriter marshals ColorInfo to the provided writer.
func (m *ColorInfo) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, val := range m.RGB {
		writer.WriteBytes(1, val)
	}

	if len(m.Legend) > 0 {
		writer.WriteString(2, m.Legend)
	}

	return
}

// Marshal marshals ColorInfo to a slice of bytes.
func (m *ColorInfo) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ColorInfo from the provided reader.
func (m *ColorInfo) UnmarshalFromReader(reader jspb.Reader) *ColorInfo {
	for reader.Next() {
		if m == nil {
			m = &ColorInfo{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.RGB = append(m.RGB, reader.ReadBytes())
		case 2:
			m.Legend = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ColorInfo from a slice of bytes.
func (m *ColorInfo) Unmarshal(rawBytes []byte) (*ColorInfo, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type FinalDemandInput struct {
	FinalDemandType FinalDemandType
	EndUseMask      *Mask
	Year            int32
	Location        Location
}

// GetFinalDemandType gets the FinalDemandType of the FinalDemandInput.
func (m *FinalDemandInput) GetFinalDemandType() (x FinalDemandType) {
	if m == nil {
		return x
	}
	return m.FinalDemandType
}

// GetEndUseMask gets the EndUseMask of the FinalDemandInput.
func (m *FinalDemandInput) GetEndUseMask() (x *Mask) {
	if m == nil {
		return x
	}
	return m.EndUseMask
}

// GetYear gets the Year of the FinalDemandInput.
func (m *FinalDemandInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the FinalDemandInput.
func (m *FinalDemandInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// MarshalToWriter marshals FinalDemandInput to the provided writer.
func (m *FinalDemandInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if int(m.FinalDemandType) != 0 {
		writer.WriteEnum(1, int(m.FinalDemandType))
	}

	if m.EndUseMask != nil {
		writer.WriteMessage(2, func() {
			m.EndUseMask.MarshalToWriter(writer)
		})
	}

	if m.Year != 0 {
		writer.WriteInt32(3, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(4, int(m.Location))
	}

	return
}

// Marshal marshals FinalDemandInput to a slice of bytes.
func (m *FinalDemandInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a FinalDemandInput from the provided reader.
func (m *FinalDemandInput) UnmarshalFromReader(reader jspb.Reader) *FinalDemandInput {
	for reader.Next() {
		if m == nil {
			m = &FinalDemandInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.FinalDemandType = FinalDemandType(reader.ReadEnum())
		case 2:
			reader.ReadMessage(func() {
				m.EndUseMask = m.EndUseMask.UnmarshalFromReader(reader)
			})
		case 3:
			m.Year = reader.ReadInt32()
		case 4:
			m.Location = Location(reader.ReadEnum())
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a FinalDemandInput from a slice of bytes.
func (m *FinalDemandInput) Unmarshal(rawBytes []byte) (*FinalDemandInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type DemographicConsumptionInput struct {
	Demograph  Demograph
	EndUseMask *Mask
	Year       int32
}

// GetDemograph gets the Demograph of the DemographicConsumptionInput.
func (m *DemographicConsumptionInput) GetDemograph() (x Demograph) {
	if m == nil {
		return x
	}
	return m.Demograph
}

// GetEndUseMask gets the EndUseMask of the DemographicConsumptionInput.
func (m *DemographicConsumptionInput) GetEndUseMask() (x *Mask) {
	if m == nil {
		return x
	}
	return m.EndUseMask
}

// GetYear gets the Year of the DemographicConsumptionInput.
func (m *DemographicConsumptionInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// MarshalToWriter marshals DemographicConsumptionInput to the provided writer.
func (m *DemographicConsumptionInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if int(m.Demograph) != 0 {
		writer.WriteEnum(1, int(m.Demograph))
	}

	if m.EndUseMask != nil {
		writer.WriteMessage(2, func() {
			m.EndUseMask.MarshalToWriter(writer)
		})
	}

	if m.Year != 0 {
		writer.WriteInt32(3, m.Year)
	}

	return
}

// Marshal marshals DemographicConsumptionInput to a slice of bytes.
func (m *DemographicConsumptionInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DemographicConsumptionInput from the provided reader.
func (m *DemographicConsumptionInput) UnmarshalFromReader(reader jspb.Reader) *DemographicConsumptionInput {
	for reader.Next() {
		if m == nil {
			m = &DemographicConsumptionInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Demograph = Demograph(reader.ReadEnum())
		case 2:
			reader.ReadMessage(func() {
				m.EndUseMask = m.EndUseMask.UnmarshalFromReader(reader)
			})
		case 3:
			m.Year = reader.ReadInt32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DemographicConsumptionInput from a slice of bytes.
func (m *DemographicConsumptionInput) Unmarshal(rawBytes []byte) (*DemographicConsumptionInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ConcentrationMatrixInput struct {
	Demand    *Vector
	Pollutant Pollutant
	Year      int32
	Location  Location
	AQM       string
}

// GetDemand gets the Demand of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetDemand() (x *Vector) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetPollutant gets the Pollutant of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetYear gets the Year of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetAQM gets the AQM of the ConcentrationMatrixInput.
func (m *ConcentrationMatrixInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals ConcentrationMatrixInput to the provided writer.
func (m *ConcentrationMatrixInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Demand != nil {
		writer.WriteMessage(1, func() {
			m.Demand.MarshalToWriter(writer)
		})
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	if m.Year != 0 {
		writer.WriteInt32(3, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(4, int(m.Location))
	}

	if len(m.AQM) > 0 {
		writer.WriteString(5, m.AQM)
	}

	return
}

// Marshal marshals ConcentrationMatrixInput to a slice of bytes.
func (m *ConcentrationMatrixInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ConcentrationMatrixInput from the provided reader.
func (m *ConcentrationMatrixInput) UnmarshalFromReader(reader jspb.Reader) *ConcentrationMatrixInput {
	for reader.Next() {
		if m == nil {
			m = &ConcentrationMatrixInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Demand = m.Demand.UnmarshalFromReader(reader)
			})
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 3:
			m.Year = reader.ReadInt32()
		case 4:
			m.Location = Location(reader.ReadEnum())
		case 5:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ConcentrationMatrixInput from a slice of bytes.
func (m *ConcentrationMatrixInput) Unmarshal(rawBytes []byte) (*ConcentrationMatrixInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ConcentrationInput struct {
	Demand    *Vector
	Emitters  *Mask
	Pollutant Pollutant
	Year      int32
	Location  Location
	AQM       string
}

// GetDemand gets the Demand of the ConcentrationInput.
func (m *ConcentrationInput) GetDemand() (x *Vector) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetEmitters gets the Emitters of the ConcentrationInput.
func (m *ConcentrationInput) GetEmitters() (x *Mask) {
	if m == nil {
		return x
	}
	return m.Emitters
}

// GetPollutant gets the Pollutant of the ConcentrationInput.
func (m *ConcentrationInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetYear gets the Year of the ConcentrationInput.
func (m *ConcentrationInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the ConcentrationInput.
func (m *ConcentrationInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetAQM gets the AQM of the ConcentrationInput.
func (m *ConcentrationInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals ConcentrationInput to the provided writer.
func (m *ConcentrationInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Demand != nil {
		writer.WriteMessage(1, func() {
			m.Demand.MarshalToWriter(writer)
		})
	}

	if m.Emitters != nil {
		writer.WriteMessage(2, func() {
			m.Emitters.MarshalToWriter(writer)
		})
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(3, int(m.Pollutant))
	}

	if m.Year != 0 {
		writer.WriteInt32(4, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(5, int(m.Location))
	}

	if len(m.AQM) > 0 {
		writer.WriteString(6, m.AQM)
	}

	return
}

// Marshal marshals ConcentrationInput to a slice of bytes.
func (m *ConcentrationInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ConcentrationInput from the provided reader.
func (m *ConcentrationInput) UnmarshalFromReader(reader jspb.Reader) *ConcentrationInput {
	for reader.Next() {
		if m == nil {
			m = &ConcentrationInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Demand = m.Demand.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.Emitters = m.Emitters.UnmarshalFromReader(reader)
			})
		case 3:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 4:
			m.Year = reader.ReadInt32()
		case 5:
			m.Location = Location(reader.ReadEnum())
		case 6:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ConcentrationInput from a slice of bytes.
func (m *ConcentrationInput) Unmarshal(rawBytes []byte) (*ConcentrationInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EmissionsMatrixInput struct {
	Demand   *Vector
	Emission Emission
	Year     int32
	Location Location
	AQM      string
}

// GetDemand gets the Demand of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetDemand() (x *Vector) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetEmission gets the Emission of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetEmission() (x Emission) {
	if m == nil {
		return x
	}
	return m.Emission
}

// GetYear gets the Year of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetAQM gets the AQM of the EmissionsMatrixInput.
func (m *EmissionsMatrixInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals EmissionsMatrixInput to the provided writer.
func (m *EmissionsMatrixInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Demand != nil {
		writer.WriteMessage(1, func() {
			m.Demand.MarshalToWriter(writer)
		})
	}

	if int(m.Emission) != 0 {
		writer.WriteEnum(2, int(m.Emission))
	}

	if m.Year != 0 {
		writer.WriteInt32(3, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(4, int(m.Location))
	}

	if len(m.AQM) > 0 {
		writer.WriteString(5, m.AQM)
	}

	return
}

// Marshal marshals EmissionsMatrixInput to a slice of bytes.
func (m *EmissionsMatrixInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EmissionsMatrixInput from the provided reader.
func (m *EmissionsMatrixInput) UnmarshalFromReader(reader jspb.Reader) *EmissionsMatrixInput {
	for reader.Next() {
		if m == nil {
			m = &EmissionsMatrixInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Demand = m.Demand.UnmarshalFromReader(reader)
			})
		case 2:
			m.Emission = Emission(reader.ReadEnum())
		case 3:
			m.Year = reader.ReadInt32()
		case 4:
			m.Location = Location(reader.ReadEnum())
		case 5:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EmissionsMatrixInput from a slice of bytes.
func (m *EmissionsMatrixInput) Unmarshal(rawBytes []byte) (*EmissionsMatrixInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EmissionsInput struct {
	Demand   *Vector
	Emitters *Mask
	Emission Emission
	Year     int32
	Location Location
	AQM      string
}

// GetDemand gets the Demand of the EmissionsInput.
func (m *EmissionsInput) GetDemand() (x *Vector) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetEmitters gets the Emitters of the EmissionsInput.
func (m *EmissionsInput) GetEmitters() (x *Mask) {
	if m == nil {
		return x
	}
	return m.Emitters
}

// GetEmission gets the Emission of the EmissionsInput.
func (m *EmissionsInput) GetEmission() (x Emission) {
	if m == nil {
		return x
	}
	return m.Emission
}

// GetYear gets the Year of the EmissionsInput.
func (m *EmissionsInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the EmissionsInput.
func (m *EmissionsInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetAQM gets the AQM of the EmissionsInput.
func (m *EmissionsInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals EmissionsInput to the provided writer.
func (m *EmissionsInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Demand != nil {
		writer.WriteMessage(1, func() {
			m.Demand.MarshalToWriter(writer)
		})
	}

	if m.Emitters != nil {
		writer.WriteMessage(2, func() {
			m.Emitters.MarshalToWriter(writer)
		})
	}

	if int(m.Emission) != 0 {
		writer.WriteEnum(3, int(m.Emission))
	}

	if m.Year != 0 {
		writer.WriteInt32(4, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(5, int(m.Location))
	}

	if len(m.AQM) > 0 {
		writer.WriteString(6, m.AQM)
	}

	return
}

// Marshal marshals EmissionsInput to a slice of bytes.
func (m *EmissionsInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EmissionsInput from the provided reader.
func (m *EmissionsInput) UnmarshalFromReader(reader jspb.Reader) *EmissionsInput {
	for reader.Next() {
		if m == nil {
			m = &EmissionsInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Demand = m.Demand.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.Emitters = m.Emitters.UnmarshalFromReader(reader)
			})
		case 3:
			m.Emission = Emission(reader.ReadEnum())
		case 4:
			m.Year = reader.ReadInt32()
		case 5:
			m.Location = Location(reader.ReadEnum())
		case 6:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EmissionsInput from a slice of bytes.
func (m *EmissionsInput) Unmarshal(rawBytes []byte) (*EmissionsInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HealthMatrixInput struct {
	Demand     *Vector
	Pollutant  Pollutant
	Population string
	Year       int32
	Location   Location
	HR         string
	AQM        string
}

// GetDemand gets the Demand of the HealthMatrixInput.
func (m *HealthMatrixInput) GetDemand() (x *Vector) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetPollutant gets the Pollutant of the HealthMatrixInput.
func (m *HealthMatrixInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetPopulation gets the Population of the HealthMatrixInput.
func (m *HealthMatrixInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetYear gets the Year of the HealthMatrixInput.
func (m *HealthMatrixInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the HealthMatrixInput.
func (m *HealthMatrixInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetHR gets the HR of the HealthMatrixInput.
func (m *HealthMatrixInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// GetAQM gets the AQM of the HealthMatrixInput.
func (m *HealthMatrixInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals HealthMatrixInput to the provided writer.
func (m *HealthMatrixInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Demand != nil {
		writer.WriteMessage(1, func() {
			m.Demand.MarshalToWriter(writer)
		})
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	if len(m.Population) > 0 {
		writer.WriteString(3, m.Population)
	}

	if m.Year != 0 {
		writer.WriteInt32(4, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(5, int(m.Location))
	}

	if len(m.HR) > 0 {
		writer.WriteString(6, m.HR)
	}

	if len(m.AQM) > 0 {
		writer.WriteString(7, m.AQM)
	}

	return
}

// Marshal marshals HealthMatrixInput to a slice of bytes.
func (m *HealthMatrixInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HealthMatrixInput from the provided reader.
func (m *HealthMatrixInput) UnmarshalFromReader(reader jspb.Reader) *HealthMatrixInput {
	for reader.Next() {
		if m == nil {
			m = &HealthMatrixInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Demand = m.Demand.UnmarshalFromReader(reader)
			})
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 3:
			m.Population = reader.ReadString()
		case 4:
			m.Year = reader.ReadInt32()
		case 5:
			m.Location = Location(reader.ReadEnum())
		case 6:
			m.HR = reader.ReadString()
		case 7:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HealthMatrixInput from a slice of bytes.
func (m *HealthMatrixInput) Unmarshal(rawBytes []byte) (*HealthMatrixInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HealthInput struct {
	Demand      *Vector
	EmitterMask *Mask
	Pollutant   Pollutant
	Population  string
	Year        int32
	Location    Location
	HR          string
	AQM         string
}

// GetDemand gets the Demand of the HealthInput.
func (m *HealthInput) GetDemand() (x *Vector) {
	if m == nil {
		return x
	}
	return m.Demand
}

// GetEmitterMask gets the EmitterMask of the HealthInput.
func (m *HealthInput) GetEmitterMask() (x *Mask) {
	if m == nil {
		return x
	}
	return m.EmitterMask
}

// GetPollutant gets the Pollutant of the HealthInput.
func (m *HealthInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetPopulation gets the Population of the HealthInput.
func (m *HealthInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetYear gets the Year of the HealthInput.
func (m *HealthInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetLocation gets the Location of the HealthInput.
func (m *HealthInput) GetLocation() (x Location) {
	if m == nil {
		return x
	}
	return m.Location
}

// GetHR gets the HR of the HealthInput.
func (m *HealthInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// GetAQM gets the AQM of the HealthInput.
func (m *HealthInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals HealthInput to the provided writer.
func (m *HealthInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Demand != nil {
		writer.WriteMessage(1, func() {
			m.Demand.MarshalToWriter(writer)
		})
	}

	if m.EmitterMask != nil {
		writer.WriteMessage(2, func() {
			m.EmitterMask.MarshalToWriter(writer)
		})
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(3, int(m.Pollutant))
	}

	if len(m.Population) > 0 {
		writer.WriteString(4, m.Population)
	}

	if m.Year != 0 {
		writer.WriteInt32(5, m.Year)
	}

	if int(m.Location) != 0 {
		writer.WriteEnum(6, int(m.Location))
	}

	if len(m.HR) > 0 {
		writer.WriteString(7, m.HR)
	}

	if len(m.AQM) > 0 {
		writer.WriteString(8, m.AQM)
	}

	return
}

// Marshal marshals HealthInput to a slice of bytes.
func (m *HealthInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HealthInput from the provided reader.
func (m *HealthInput) UnmarshalFromReader(reader jspb.Reader) *HealthInput {
	for reader.Next() {
		if m == nil {
			m = &HealthInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Demand = m.Demand.UnmarshalFromReader(reader)
			})
		case 2:
			reader.ReadMessage(func() {
				m.EmitterMask = m.EmitterMask.UnmarshalFromReader(reader)
			})
		case 3:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 4:
			m.Population = reader.ReadString()
		case 5:
			m.Year = reader.ReadInt32()
		case 6:
			m.Location = Location(reader.ReadEnum())
		case 7:
			m.HR = reader.ReadString()
		case 8:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HealthInput from a slice of bytes.
func (m *HealthInput) Unmarshal(rawBytes []byte) (*HealthInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Vector struct {
	Data []float64
}

// GetData gets the Data of the Vector.
func (m *Vector) GetData() (x []float64) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals Vector to the provided writer.
func (m *Vector) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Data) > 0 {
		writer.WriteFloat64Slice(1, m.Data)
	}

	return
}

// Marshal marshals Vector to a slice of bytes.
func (m *Vector) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Vector from the provided reader.
func (m *Vector) UnmarshalFromReader(reader jspb.Reader) *Vector {
	for reader.Next() {
		if m == nil {
			m = &Vector{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Data = reader.ReadFloat64Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Vector from a slice of bytes.
func (m *Vector) Unmarshal(rawBytes []byte) (*Vector, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Mask struct {
	Data []float64
}

// GetData gets the Data of the Mask.
func (m *Mask) GetData() (x []float64) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals Mask to the provided writer.
func (m *Mask) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Data) > 0 {
		writer.WriteFloat64Slice(1, m.Data)
	}

	return
}

// Marshal marshals Mask to a slice of bytes.
func (m *Mask) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Mask from the provided reader.
func (m *Mask) UnmarshalFromReader(reader jspb.Reader) *Mask {
	for reader.Next() {
		if m == nil {
			m = &Mask{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Data = reader.ReadFloat64Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Mask from a slice of bytes.
func (m *Mask) Unmarshal(rawBytes []byte) (*Mask, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Matrix struct {
	Rows int32
	Cols int32
	Data []float64
}

// GetRows gets the Rows of the Matrix.
func (m *Matrix) GetRows() (x int32) {
	if m == nil {
		return x
	}
	return m.Rows
}

// GetCols gets the Cols of the Matrix.
func (m *Matrix) GetCols() (x int32) {
	if m == nil {
		return x
	}
	return m.Cols
}

// GetData gets the Data of the Matrix.
func (m *Matrix) GetData() (x []float64) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals Matrix to the provided writer.
func (m *Matrix) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Rows != 0 {
		writer.WriteInt32(1, m.Rows)
	}

	if m.Cols != 0 {
		writer.WriteInt32(2, m.Cols)
	}

	if len(m.Data) > 0 {
		writer.WriteFloat64Slice(3, m.Data)
	}

	return
}

// Marshal marshals Matrix to a slice of bytes.
func (m *Matrix) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Matrix from the provided reader.
func (m *Matrix) UnmarshalFromReader(reader jspb.Reader) *Matrix {
	for reader.Next() {
		if m == nil {
			m = &Matrix{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Rows = reader.ReadInt32()
		case 2:
			m.Cols = reader.ReadInt32()
		case 3:
			m.Data = reader.ReadFloat64Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Matrix from a slice of bytes.
func (m *Matrix) Unmarshal(rawBytes []byte) (*Matrix, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EvaluationHealthInput struct {
	Year       int32
	Pollutant  Pollutant
	Population string
	HR         string
	AQM        string
}

// GetYear gets the Year of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPollutant gets the Pollutant of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetPopulation gets the Population of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetHR gets the HR of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// GetAQM gets the AQM of the EvaluationHealthInput.
func (m *EvaluationHealthInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals EvaluationHealthInput to the provided writer.
func (m *EvaluationHealthInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	if len(m.Population) > 0 {
		writer.WriteString(3, m.Population)
	}

	if len(m.HR) > 0 {
		writer.WriteString(4, m.HR)
	}

	if len(m.AQM) > 0 {
		writer.WriteString(5, m.AQM)
	}

	return
}

// Marshal marshals EvaluationHealthInput to a slice of bytes.
func (m *EvaluationHealthInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EvaluationHealthInput from the provided reader.
func (m *EvaluationHealthInput) UnmarshalFromReader(reader jspb.Reader) *EvaluationHealthInput {
	for reader.Next() {
		if m == nil {
			m = &EvaluationHealthInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 3:
			m.Population = reader.ReadString()
		case 4:
			m.HR = reader.ReadString()
		case 5:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EvaluationHealthInput from a slice of bytes.
func (m *EvaluationHealthInput) Unmarshal(rawBytes []byte) (*EvaluationHealthInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EvaluationConcentrationsInput struct {
	Year      int32
	Pollutant Pollutant
	AQM       string
}

// GetYear gets the Year of the EvaluationConcentrationsInput.
func (m *EvaluationConcentrationsInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPollutant gets the Pollutant of the EvaluationConcentrationsInput.
func (m *EvaluationConcentrationsInput) GetPollutant() (x Pollutant) {
	if m == nil {
		return x
	}
	return m.Pollutant
}

// GetAQM gets the AQM of the EvaluationConcentrationsInput.
func (m *EvaluationConcentrationsInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals EvaluationConcentrationsInput to the provided writer.
func (m *EvaluationConcentrationsInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if int(m.Pollutant) != 0 {
		writer.WriteEnum(2, int(m.Pollutant))
	}

	if len(m.AQM) > 0 {
		writer.WriteString(3, m.AQM)
	}

	return
}

// Marshal marshals EvaluationConcentrationsInput to a slice of bytes.
func (m *EvaluationConcentrationsInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EvaluationConcentrationsInput from the provided reader.
func (m *EvaluationConcentrationsInput) UnmarshalFromReader(reader jspb.Reader) *EvaluationConcentrationsInput {
	for reader.Next() {
		if m == nil {
			m = &EvaluationConcentrationsInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Pollutant = Pollutant(reader.ReadEnum())
		case 3:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EvaluationConcentrationsInput from a slice of bytes.
func (m *EvaluationConcentrationsInput) Unmarshal(rawBytes []byte) (*EvaluationConcentrationsInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ConcentrationResponseAverageInput struct {
	Year       int32
	Population string
	HR         string
	AQM        string
}

// GetYear gets the Year of the ConcentrationResponseAverageInput.
func (m *ConcentrationResponseAverageInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPopulation gets the Population of the ConcentrationResponseAverageInput.
func (m *ConcentrationResponseAverageInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetHR gets the HR of the ConcentrationResponseAverageInput.
func (m *ConcentrationResponseAverageInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// GetAQM gets the AQM of the ConcentrationResponseAverageInput.
func (m *ConcentrationResponseAverageInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals ConcentrationResponseAverageInput to the provided writer.
func (m *ConcentrationResponseAverageInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if len(m.Population) > 0 {
		writer.WriteString(2, m.Population)
	}

	if len(m.HR) > 0 {
		writer.WriteString(3, m.HR)
	}

	if len(m.AQM) > 0 {
		writer.WriteString(4, m.AQM)
	}

	return
}

// Marshal marshals ConcentrationResponseAverageInput to a slice of bytes.
func (m *ConcentrationResponseAverageInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ConcentrationResponseAverageInput from the provided reader.
func (m *ConcentrationResponseAverageInput) UnmarshalFromReader(reader jspb.Reader) *ConcentrationResponseAverageInput {
	for reader.Next() {
		if m == nil {
			m = &ConcentrationResponseAverageInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Population = reader.ReadString()
		case 3:
			m.HR = reader.ReadString()
		case 4:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ConcentrationResponseAverageInput from a slice of bytes.
func (m *ConcentrationResponseAverageInput) Unmarshal(rawBytes []byte) (*ConcentrationResponseAverageInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type PopulationIncidenceInput struct {
	Year       int32
	Population string
	HR         string
	AQM        string
}

// GetYear gets the Year of the PopulationIncidenceInput.
func (m *PopulationIncidenceInput) GetYear() (x int32) {
	if m == nil {
		return x
	}
	return m.Year
}

// GetPopulation gets the Population of the PopulationIncidenceInput.
func (m *PopulationIncidenceInput) GetPopulation() (x string) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetHR gets the HR of the PopulationIncidenceInput.
func (m *PopulationIncidenceInput) GetHR() (x string) {
	if m == nil {
		return x
	}
	return m.HR
}

// GetAQM gets the AQM of the PopulationIncidenceInput.
func (m *PopulationIncidenceInput) GetAQM() (x string) {
	if m == nil {
		return x
	}
	return m.AQM
}

// MarshalToWriter marshals PopulationIncidenceInput to the provided writer.
func (m *PopulationIncidenceInput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Year != 0 {
		writer.WriteInt32(1, m.Year)
	}

	if len(m.Population) > 0 {
		writer.WriteString(2, m.Population)
	}

	if len(m.HR) > 0 {
		writer.WriteString(3, m.HR)
	}

	if len(m.AQM) > 0 {
		writer.WriteString(4, m.AQM)
	}

	return
}

// Marshal marshals PopulationIncidenceInput to a slice of bytes.
func (m *PopulationIncidenceInput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a PopulationIncidenceInput from the provided reader.
func (m *PopulationIncidenceInput) UnmarshalFromReader(reader jspb.Reader) *PopulationIncidenceInput {
	for reader.Next() {
		if m == nil {
			m = &PopulationIncidenceInput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Year = reader.ReadInt32()
		case 2:
			m.Population = reader.ReadString()
		case 3:
			m.HR = reader.ReadString()
		case 4:
			m.AQM = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a PopulationIncidenceInput from a slice of bytes.
func (m *PopulationIncidenceInput) Unmarshal(rawBytes []byte) (*PopulationIncidenceInput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type PopulationIncidenceOutput struct {
	Population []float64
	Incidence  []float64
}

// GetPopulation gets the Population of the PopulationIncidenceOutput.
func (m *PopulationIncidenceOutput) GetPopulation() (x []float64) {
	if m == nil {
		return x
	}
	return m.Population
}

// GetIncidence gets the Incidence of the PopulationIncidenceOutput.
func (m *PopulationIncidenceOutput) GetIncidence() (x []float64) {
	if m == nil {
		return x
	}
	return m.Incidence
}

// MarshalToWriter marshals PopulationIncidenceOutput to the provided writer.
func (m *PopulationIncidenceOutput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Population) > 0 {
		writer.WriteFloat64Slice(1, m.Population)
	}

	if len(m.Incidence) > 0 {
		writer.WriteFloat64Slice(2, m.Incidence)
	}

	return
}

// Marshal marshals PopulationIncidenceOutput to a slice of bytes.
func (m *PopulationIncidenceOutput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a PopulationIncidenceOutput from the provided reader.
func (m *PopulationIncidenceOutput) UnmarshalFromReader(reader jspb.Reader) *PopulationIncidenceOutput {
	for reader.Next() {
		if m == nil {
			m = &PopulationIncidenceOutput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Population = reader.ReadFloat64Slice()
		case 2:
			m.Incidence = reader.ReadFloat64Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a PopulationIncidenceOutput from a slice of bytes.
func (m *PopulationIncidenceOutput) Unmarshal(rawBytes []byte) (*PopulationIncidenceOutput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for EIEIOrpc service

type EIEIOrpcClient interface {
	EndUseGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	EndUseSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	EmitterGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	EmitterSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	Years(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Year, error)
	DefaultSelection(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selection, error)
	Populations(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error)
	MapInfo(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*ColorInfo, error)
	Geometry(ctx context.Context, in *GeometryInput, opts ...grpcweb.CallOption) (*Rectangles, error)
	Concentrations(ctx context.Context, in *ConcentrationInput, opts ...grpcweb.CallOption) (*Vector, error)
	ConcentrationMatrix(ctx context.Context, in *ConcentrationMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error)
	Emissions(ctx context.Context, in *EmissionsInput, opts ...grpcweb.CallOption) (*Vector, error)
	EmissionsMatrix(ctx context.Context, in *EmissionsMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error)
	Health(ctx context.Context, in *HealthInput, opts ...grpcweb.CallOption) (*Vector, error)
	HealthMatrix(ctx context.Context, in *HealthMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error)
	EvaluationHealth(ctx context.Context, in *EvaluationHealthInput, opts ...grpcweb.CallOption) (*Vector, error)
	EvaluationConcentrations(ctx context.Context, in *EvaluationConcentrationsInput, opts ...grpcweb.CallOption) (*Vector, error)
	ConcentrationResponseAverage(ctx context.Context, in *ConcentrationResponseAverageInput, opts ...grpcweb.CallOption) (*Vector, error)
	PopulationIncidence(ctx context.Context, in *PopulationIncidenceInput, opts ...grpcweb.CallOption) (*PopulationIncidenceOutput, error)
	FinalDemand(ctx context.Context, in *FinalDemandInput, opts ...grpcweb.CallOption) (*Vector, error)
	EndUseMask(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*Mask, error)
	EmitterMask(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*Mask, error)
	EndUseGroupNames(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error)
	EndUseGroupAbbrevs(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error)
	EmitterGroupNames(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error)
	EmitterGroupAbbrevs(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error)
	Commodities(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error)
	Industries(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error)
	DemographicConsumption(ctx context.Context, in *DemographicConsumptionInput, opts ...grpcweb.CallOption) (*Vector, error)
}

type eIEIOrpcClient struct {
	client *grpcweb.Client
}

// NewEIEIOrpcClient creates a new gRPC-Web client.
func NewEIEIOrpcClient(hostname string, opts ...grpcweb.DialOption) EIEIOrpcClient {
	return &eIEIOrpcClient{
		client: grpcweb.NewClient(hostname, "eieiorpc.EIEIOrpc", opts...),
	}
}

func (c *eIEIOrpcClient) EndUseGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "EndUseGroups", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EndUseSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "EndUseSectors", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EmitterGroups(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "EmitterGroups", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EmitterSectors(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "EmitterSectors", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Years(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Year, error) {
	resp, err := c.client.RPCCall(ctx, "Years", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Year).Unmarshal(resp)
}

func (c *eIEIOrpcClient) DefaultSelection(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selection, error) {
	resp, err := c.client.RPCCall(ctx, "DefaultSelection", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selection).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Populations(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*Selectors, error) {
	resp, err := c.client.RPCCall(ctx, "Populations", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Selectors).Unmarshal(resp)
}

func (c *eIEIOrpcClient) MapInfo(ctx context.Context, in *Selection, opts ...grpcweb.CallOption) (*ColorInfo, error) {
	resp, err := c.client.RPCCall(ctx, "MapInfo", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ColorInfo).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Geometry(ctx context.Context, in *GeometryInput, opts ...grpcweb.CallOption) (*Rectangles, error) {
	resp, err := c.client.RPCCall(ctx, "Geometry", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Rectangles).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Concentrations(ctx context.Context, in *ConcentrationInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "Concentrations", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) ConcentrationMatrix(ctx context.Context, in *ConcentrationMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error) {
	resp, err := c.client.RPCCall(ctx, "ConcentrationMatrix", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Matrix).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Emissions(ctx context.Context, in *EmissionsInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "Emissions", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EmissionsMatrix(ctx context.Context, in *EmissionsMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error) {
	resp, err := c.client.RPCCall(ctx, "EmissionsMatrix", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Matrix).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Health(ctx context.Context, in *HealthInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "Health", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) HealthMatrix(ctx context.Context, in *HealthMatrixInput, opts ...grpcweb.CallOption) (*Matrix, error) {
	resp, err := c.client.RPCCall(ctx, "HealthMatrix", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Matrix).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EvaluationHealth(ctx context.Context, in *EvaluationHealthInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "EvaluationHealth", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EvaluationConcentrations(ctx context.Context, in *EvaluationConcentrationsInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "EvaluationConcentrations", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) ConcentrationResponseAverage(ctx context.Context, in *ConcentrationResponseAverageInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "ConcentrationResponseAverage", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) PopulationIncidence(ctx context.Context, in *PopulationIncidenceInput, opts ...grpcweb.CallOption) (*PopulationIncidenceOutput, error) {
	resp, err := c.client.RPCCall(ctx, "PopulationIncidence", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(PopulationIncidenceOutput).Unmarshal(resp)
}

func (c *eIEIOrpcClient) FinalDemand(ctx context.Context, in *FinalDemandInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "FinalDemand", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EndUseMask(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*Mask, error) {
	resp, err := c.client.RPCCall(ctx, "EndUseMask", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Mask).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EmitterMask(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*Mask, error) {
	resp, err := c.client.RPCCall(ctx, "EmitterMask", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Mask).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EndUseGroupNames(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error) {
	resp, err := c.client.RPCCall(ctx, "EndUseGroupNames", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(StringList).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EndUseGroupAbbrevs(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error) {
	resp, err := c.client.RPCCall(ctx, "EndUseGroupAbbrevs", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(StringList).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EmitterGroupNames(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error) {
	resp, err := c.client.RPCCall(ctx, "EmitterGroupNames", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(StringList).Unmarshal(resp)
}

func (c *eIEIOrpcClient) EmitterGroupAbbrevs(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error) {
	resp, err := c.client.RPCCall(ctx, "EmitterGroupAbbrevs", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(StringList).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Commodities(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error) {
	resp, err := c.client.RPCCall(ctx, "Commodities", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(StringList).Unmarshal(resp)
}

func (c *eIEIOrpcClient) Industries(ctx context.Context, in *StringInput, opts ...grpcweb.CallOption) (*StringList, error) {
	resp, err := c.client.RPCCall(ctx, "Industries", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(StringList).Unmarshal(resp)
}

func (c *eIEIOrpcClient) DemographicConsumption(ctx context.Context, in *DemographicConsumptionInput, opts ...grpcweb.CallOption) (*Vector, error) {
	resp, err := c.client.RPCCall(ctx, "DemographicConsumption", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Vector).Unmarshal(resp)
}
