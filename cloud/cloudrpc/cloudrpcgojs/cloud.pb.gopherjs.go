// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: cloud.proto

/*
	Package cloudrpc is a generated protocol buffer package.

	It is generated from these files:
		cloud.proto

	It has these top-level messages:
		JobSpec
		JobStatus
		JobOutput
		JobName
*/
package cloudrpc

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type Status int

const (
	Status_Complete Status = 0
	Status_Failed   Status = 1
	Status_Missing  Status = 2
	Status_Running  Status = 3
	Status_Waiting  Status = 4
)

var Status_name = map[int]string{
	0: "Complete",
	1: "Failed",
	2: "Missing",
	3: "Running",
	4: "Waiting",
}
var Status_value = map[string]int{
	"Complete": 0,
	"Failed":   1,
	"Missing":  2,
	"Running":  3,
	"Waiting":  4,
}

func (x Status) String() string {
	return Status_name[int(x)]
}

// JobSpec is the input for the RunJob service.
type JobSpec struct {
	// Version is the required InMAP version.
	Version string
	// Name is a user-specified name for the job.
	Name string
	// Cmd is the command to be run, e.g., [inmap run steady]
	Cmd []string
	// Args are the command line arguments, e.g., [--Layers, 2, --steady, true]
	Args []string
	// MemoryGB specifies the required gigabytes of RAM memory for the
	// simulation.
	MemoryGB int32
	// FileData holds the contents of any local files referred to by Args
	FileData map[string][]byte
}

// GetVersion gets the Version of the JobSpec.
func (m *JobSpec) GetVersion() (x string) {
	if m == nil {
		return x
	}
	return m.Version
}

// GetName gets the Name of the JobSpec.
func (m *JobSpec) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetCmd gets the Cmd of the JobSpec.
func (m *JobSpec) GetCmd() (x []string) {
	if m == nil {
		return x
	}
	return m.Cmd
}

// GetArgs gets the Args of the JobSpec.
func (m *JobSpec) GetArgs() (x []string) {
	if m == nil {
		return x
	}
	return m.Args
}

// GetMemoryGB gets the MemoryGB of the JobSpec.
func (m *JobSpec) GetMemoryGB() (x int32) {
	if m == nil {
		return x
	}
	return m.MemoryGB
}

// GetFileData gets the FileData of the JobSpec.
func (m *JobSpec) GetFileData() (x map[string][]byte) {
	if m == nil {
		return x
	}
	return m.FileData
}

// MarshalToWriter marshals JobSpec to the provided writer.
func (m *JobSpec) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Version) > 0 {
		writer.WriteString(1, m.Version)
	}

	if len(m.Name) > 0 {
		writer.WriteString(2, m.Name)
	}

	for _, val := range m.Cmd {
		writer.WriteString(3, val)
	}

	for _, val := range m.Args {
		writer.WriteString(4, val)
	}

	if m.MemoryGB != 0 {
		writer.WriteInt32(5, m.MemoryGB)
	}

	if len(m.FileData) > 0 {
		for key, value := range m.FileData {
			writer.WriteMessage(7, func() {
				writer.WriteString(1, key)
				writer.WriteBytes(2, value)
			})
		}
	}

	return
}

// Marshal marshals JobSpec to a slice of bytes.
func (m *JobSpec) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a JobSpec from the provided reader.
func (m *JobSpec) UnmarshalFromReader(reader jspb.Reader) *JobSpec {
	for reader.Next() {
		if m == nil {
			m = &JobSpec{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Version = reader.ReadString()
		case 2:
			m.Name = reader.ReadString()
		case 3:
			m.Cmd = append(m.Cmd, reader.ReadString())
		case 4:
			m.Args = append(m.Args, reader.ReadString())
		case 5:
			m.MemoryGB = reader.ReadInt32()
		case 7:
			if m.FileData == nil {
				m.FileData = map[string][]byte{}
			}
			reader.ReadMessage(func() {
				var key string
				var value []byte
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadString()
					case 2:
						value = reader.ReadBytes()
					}
					m.FileData[key] = value
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a JobSpec from a slice of bytes.
func (m *JobSpec) Unmarshal(rawBytes []byte) (*JobSpec, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type JobStatus struct {
	// Status holds the current status of the job.
	Status  Status
	Message string
	// Unix time, the number of seconds elapsed since January 1, 1970 UTC
	StartTime      int64
	CompletionTime int64
}

// GetStatus gets the Status of the JobStatus.
func (m *JobStatus) GetStatus() (x Status) {
	if m == nil {
		return x
	}
	return m.Status
}

// GetMessage gets the Message of the JobStatus.
func (m *JobStatus) GetMessage() (x string) {
	if m == nil {
		return x
	}
	return m.Message
}

// GetStartTime gets the StartTime of the JobStatus.
func (m *JobStatus) GetStartTime() (x int64) {
	if m == nil {
		return x
	}
	return m.StartTime
}

// GetCompletionTime gets the CompletionTime of the JobStatus.
func (m *JobStatus) GetCompletionTime() (x int64) {
	if m == nil {
		return x
	}
	return m.CompletionTime
}

// MarshalToWriter marshals JobStatus to the provided writer.
func (m *JobStatus) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if int(m.Status) != 0 {
		writer.WriteEnum(1, int(m.Status))
	}

	if len(m.Message) > 0 {
		writer.WriteString(2, m.Message)
	}

	if m.StartTime != 0 {
		writer.WriteInt64(3, m.StartTime)
	}

	if m.CompletionTime != 0 {
		writer.WriteInt64(4, m.CompletionTime)
	}

	return
}

// Marshal marshals JobStatus to a slice of bytes.
func (m *JobStatus) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a JobStatus from the provided reader.
func (m *JobStatus) UnmarshalFromReader(reader jspb.Reader) *JobStatus {
	for reader.Next() {
		if m == nil {
			m = &JobStatus{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Status = Status(reader.ReadEnum())
		case 2:
			m.Message = reader.ReadString()
		case 3:
			m.StartTime = reader.ReadInt64()
		case 4:
			m.CompletionTime = reader.ReadInt64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a JobStatus from a slice of bytes.
func (m *JobStatus) Unmarshal(rawBytes []byte) (*JobStatus, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type JobOutput struct {
	// Files holds the contents of each output file.
	Files map[string][]byte
}

// GetFiles gets the Files of the JobOutput.
func (m *JobOutput) GetFiles() (x map[string][]byte) {
	if m == nil {
		return x
	}
	return m.Files
}

// MarshalToWriter marshals JobOutput to the provided writer.
func (m *JobOutput) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Files) > 0 {
		for key, value := range m.Files {
			writer.WriteMessage(1, func() {
				writer.WriteString(1, key)
				writer.WriteBytes(2, value)
			})
		}
	}

	return
}

// Marshal marshals JobOutput to a slice of bytes.
func (m *JobOutput) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a JobOutput from the provided reader.
func (m *JobOutput) UnmarshalFromReader(reader jspb.Reader) *JobOutput {
	for reader.Next() {
		if m == nil {
			m = &JobOutput{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			if m.Files == nil {
				m.Files = map[string][]byte{}
			}
			reader.ReadMessage(func() {
				var key string
				var value []byte
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadString()
					case 2:
						value = reader.ReadBytes()
					}
					m.Files[key] = value
				}
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a JobOutput from a slice of bytes.
func (m *JobOutput) Unmarshal(rawBytes []byte) (*JobOutput, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type JobName struct {
	// Version is the required InMAP version.
	Version string
	// Name is a user-specified name for the job.
	Name string
}

// GetVersion gets the Version of the JobName.
func (m *JobName) GetVersion() (x string) {
	if m == nil {
		return x
	}
	return m.Version
}

// GetName gets the Name of the JobName.
func (m *JobName) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// MarshalToWriter marshals JobName to the provided writer.
func (m *JobName) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Version) > 0 {
		writer.WriteString(1, m.Version)
	}

	if len(m.Name) > 0 {
		writer.WriteString(2, m.Name)
	}

	return
}

// Marshal marshals JobName to a slice of bytes.
func (m *JobName) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a JobName from the provided reader.
func (m *JobName) UnmarshalFromReader(reader jspb.Reader) *JobName {
	for reader.Next() {
		if m == nil {
			m = &JobName{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Version = reader.ReadString()
		case 2:
			m.Name = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a JobName from a slice of bytes.
func (m *JobName) Unmarshal(rawBytes []byte) (*JobName, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for CloudRPC service

type CloudRPCClient interface {
	// RunJob performs an InMAP simulation and returns the paths to the
	// output file(s).
	RunJob(ctx context.Context, in *JobSpec, opts ...grpcweb.CallOption) (*JobStatus, error)
	// Status returns the status of the simulation with the
	// requested name.
	Status(ctx context.Context, in *JobName, opts ...grpcweb.CallOption) (*JobStatus, error)
	// Output returns the output file(s) of the
	// requested simulation name.
	Output(ctx context.Context, in *JobName, opts ...grpcweb.CallOption) (*JobOutput, error)
	// Delete deletes the specified simulation.
	Delete(ctx context.Context, in *JobName, opts ...grpcweb.CallOption) (*JobName, error)
}

type cloudRPCClient struct {
	client *grpcweb.Client
}

// NewCloudRPCClient creates a new gRPC-Web client.
func NewCloudRPCClient(hostname string, opts ...grpcweb.DialOption) CloudRPCClient {
	return &cloudRPCClient{
		client: grpcweb.NewClient(hostname, "cloudrpc.CloudRPC", opts...),
	}
}

func (c *cloudRPCClient) RunJob(ctx context.Context, in *JobSpec, opts ...grpcweb.CallOption) (*JobStatus, error) {
	resp, err := c.client.RPCCall(ctx, "RunJob", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(JobStatus).Unmarshal(resp)
}

func (c *cloudRPCClient) Status(ctx context.Context, in *JobName, opts ...grpcweb.CallOption) (*JobStatus, error) {
	resp, err := c.client.RPCCall(ctx, "Status", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(JobStatus).Unmarshal(resp)
}

func (c *cloudRPCClient) Output(ctx context.Context, in *JobName, opts ...grpcweb.CallOption) (*JobOutput, error) {
	resp, err := c.client.RPCCall(ctx, "Output", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(JobOutput).Unmarshal(resp)
}

func (c *cloudRPCClient) Delete(ctx context.Context, in *JobName, opts ...grpcweb.CallOption) (*JobName, error) {
	resp, err := c.client.RPCCall(ctx, "Delete", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(JobName).Unmarshal(resp)
}
